<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>操作系统 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.操作系统概述1.1操作系统的概念操作系统概念：负责管理协调硬件、软件等资源的工作，为上层用户、应用程序提供服务的一种系统软件 功能：处理机管理、存储器管理、文件管理、设备管理 命令接口：允许用户直接使用 程序接口：允许用户通过程序间接使用，由系统调用组成 1.2操作系统的特征 并发：宏观上同时发生，微观上交替发生 共享：计算机中的资源可供内存中多个并发执行的进程共同使用 虚拟：把物理上的实体变">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://yoursite.com/2020/07/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.操作系统概述1.1操作系统的概念操作系统概念：负责管理协调硬件、软件等资源的工作，为上层用户、应用程序提供服务的一种系统软件 功能：处理机管理、存储器管理、文件管理、设备管理 命令接口：允许用户直接使用 程序接口：允许用户通过程序间接使用，由系统调用组成 1.2操作系统的特征 并发：宏观上同时发生，微观上交替发生 共享：计算机中的资源可供内存中多个并发执行的进程共同使用 虚拟：把物理上的实体变">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-19T15:51:35.759Z">
<meta property="article:modified_time" content="2020-07-19T15:53:50.564Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-操作系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2020-07-19T15:51:35.759Z" itemprop="datePublished">2020-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      操作系统
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1.操作系统概述"></a>1.操作系统概述</h1><h2 id="1-1操作系统的概念"><a href="#1-1操作系统的概念" class="headerlink" title="1.1操作系统的概念"></a>1.1操作系统的概念</h2><p>操作系统概念：负责管理协调硬件、软件等资源的工作，为上层用户、应用程序提供服务的一种系统软件</p>
<p>功能：处理机管理、存储器管理、文件管理、设备管理</p>
<p>命令接口：允许用户直接使用</p>
<p>程序接口：允许用户通过程序间接使用，由系统调用组成</p>
<h2 id="1-2操作系统的特征"><a href="#1-2操作系统的特征" class="headerlink" title="1.2操作系统的特征"></a>1.2操作系统的特征</h2><ul>
<li>并发：宏观上同时发生，微观上交替发生</li>
<li>共享：计算机中的资源可供内存中多个并发执行的进程共同使用</li>
<li>虚拟：把物理上的实体变为若干个逻辑上的对应物，让用户感觉到超出真实实体的性能</li>
<li>异步：进程执行并非是连续的，而是以不可预知的速度进行</li>
</ul>
<p>并发与共享互为存在条件，并发性和共享性是虚拟和异步的基础</p>
<h2 id="1-3操作系统的发展"><a href="#1-3操作系统的发展" class="headerlink" title="1.3操作系统的发展"></a>1.3操作系统的发展</h2><p>四个阶段：</p>
<ul>
<li>手工操作阶段</li>
<li>批处理阶段</li>
<li><ul>
<li>单道批处理系统：提升效率，但是CPU等待I/O</li>
<li>多道批处理系统：并发执行，没有人机交互功能</li>
</ul>
</li>
<li>分时操作系统</li>
<li><ul>
<li>以时间片为单位轮流为各个用户服务，人机可交互，可立即对请求作出响应，但是不能优先处理紧急任务</li>
</ul>
</li>
<li>实时操作系统</li>
<li><ul>
<li>能够优先响应紧急任务，具有及时性和可靠性</li>
</ul>
</li>
</ul>
<h2 id="1-4操作系统的运行机制与体系结构"><a href="#1-4操作系统的运行机制与体系结构" class="headerlink" title="1.4操作系统的运行机制与体系结构"></a>1.4操作系统的运行机制与体系结构</h2><p>特权指令：不允许用户使用</p>
<p>非特权指令：普通的指令</p>
<p>用户态：用户只能执行非特权指令</p>
<p>核心态：特权指令与非特权指令都可以执行</p>
<p>内核程序：既可以执行特权指令，也可以执行非特权指令，运行在核心态</p>
<p>应用程序：只能执行非特权指令，运行在用户态</p>
<p>大内核：</p>
<ul>
<li>将操作系统的主要功能都作为系统内核，运行在核心态</li>
<li>优点：高性能</li>
<li>缺点：内核代码庞大，结构混乱，难以维护</li>
</ul>
<p>微内核：</p>
<ul>
<li>只把最基本的功能保留在内核</li>
<li>优点：内核功能少，结构清晰，方便维护</li>
<li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li>
</ul>
<h2 id="1-5中断和异常"><a href="#1-5中断和异常" class="headerlink" title="1.5中断和异常"></a>1.5中断和异常</h2><ul>
<li>中断发生时，系统立刻进入核心态</li>
<li>中断发生后，当前运行的进程暂停运行，由操作系统的内核对中断进行处理</li>
<li>对于不同的中断信号，会进行不同的处理</li>
</ul>
<p>中断是用户态到核心态的唯一途径</p>
<p>核心态到用户态是通过执行一个特权指令，将程序状态字的标志位设置为“用户态”</p>
<p>中断分为外中断和内中断</p>
<p>中断的处理过程：</p>
<ul>
<li>执行完每个指令后，CPU都要检查当前是否有外部中断信号</li>
<li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境</li>
<li>根据中断信号类型转入响应的中断处理程序</li>
<li>恢复原进程的CPU环境并退出中断，返回原进程继续向下执行</li>
</ul>
<h2 id="1-6系统调用"><a href="#1-6系统调用" class="headerlink" title="1.6系统调用"></a>1.6系统调用</h2><p>系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数。</p>
<p>系统调用的功能：</p>
<ul>
<li>设备管理</li>
<li>文件管理</li>
<li>进程管理</li>
<li>进程通信</li>
<li>内存管理</li>
</ul>
<p>系统调用的相关处理在核心态下进行</p>
<p>系统调用的过程：</p>
<ul>
<li>传递系统调用参数</li>
<li>执行陷入指令（用户态）</li>
<li>执行系统调用响应服务程序（核心态）</li>
<li>返回用户程序</li>
</ul>
<p>系统调用和库函数的区别：</p>
<ul>
<li>系统调用是操作系统向上层提供的接口</li>
<li>有的库函数是对系统调用的进一步封装</li>
<li>当今编写的应用程序大多数是通过高级语言提供的库函数间接地进行系统调用</li>
</ul>
<h1 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h1><h2 id="2-1进程的定义、组成"><a href="#2-1进程的定义、组成" class="headerlink" title="2.1进程的定义、组成"></a>2.1进程的定义、组成</h2><p>进程实体由进程控制块PCB、程序段、数据段组成</p>
<p>PCB是进程存在的唯一标志</p>
<p>进程是具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位</p>
<p>进程实体是静态的，进程是动态的，但是一般不做区分</p>
<p>PCB：</p>
<ul>
<li>进程描述信息</li>
<li>进程控制和管理信息</li>
<li>资源分配清单</li>
<li>处理机相关信息</li>
</ul>
<p>进程的组织形式：</p>
<ul>
<li>链接方式：按进程状态将PCB划分为多个队列</li>
<li>索引方式：按进程状态建立几张索引表，各表项指向一个PCB</li>
</ul>
<p>进程的特征：</p>
<ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性：资源分配、调度的独立单位</li>
<li>异步性：导致结果的不确定性</li>
<li>结构性</li>
</ul>
<h2 id="2-2进程的状态与转换"><a href="#2-2进程的状态与转换" class="headerlink" title="2.2进程的状态与转换"></a>2.2进程的状态与转换</h2><p>进程的状态：</p>
<ul>
<li>运行状态</li>
<li>就绪状态</li>
<li>阻塞状态</li>
<li>创建状态</li>
<li>终止状态</li>
</ul>
<p>进程状态间的转换</p>
<ul>
<li>就绪态$\rightarrow$ 运行态：进程被调度</li>
<li>运行态$\rightarrow$ 就绪态：时间片到，或被高优先级的进程抢占</li>
<li>运行态$\rightarrow$ 阻塞态：等待系统资源分配，或等待某事件发生</li>
<li>阻塞态$\rightarrow$ 就绪态：资源分配到位，等待的事件发生</li>
</ul>
<p>从运行态进入阻塞态是进程主动请求的</p>
<h2 id="2-3进程控制"><a href="#2-3进程控制" class="headerlink" title="2.3进程控制"></a>2.3进程控制</h2><p>进程控制实现的方式是原语</p>
<p>原语的特点是不允许中断，采用“关中断指令”与“开中断指令”实现</p>
<p>原语运行在核心态</p>
<p>原语要做的事情：</p>
<ul>
<li>更新PCB中的信息</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ul>
<h2 id="2-4进程通信"><a href="#2-4进程通信" class="headerlink" title="2.4进程通信"></a>2.4进程通信</h2><p>进程通信指进程之间的信息交换</p>
<p>一个进程不能直接访问另一个进程的地址空间</p>
<ul>
<li>共享存储：必须保证互斥性</li>
<li><ul>
<li>基于数据结构共享：低级，速度慢，限制多</li>
<li>基于存储区共享：高级，速度更快，在内存中划出共享存储区，由进程控制</li>
</ul>
</li>
<li>管道通信：在内存中开辟一个缓冲区</li>
<li><ul>
<li>只能采用半双工通信</li>
<li>保持互斥性</li>
<li>管道容量限制使得可能发生阻塞</li>
<li>如果没写满，就不允许读；如果没读空，就不允许写</li>
<li>一旦被读，就被抛弃，因此读进程最多有一个</li>
</ul>
</li>
<li>消息传递：以格式化消息为单位，系统提供“发送/接受原语”<ul>
<li>直接通信：消息直接挂到进程的消息缓冲队列上</li>
<li>间接通信：消息先发送到中间实体中</li>
</ul>
</li>
</ul>
<h2 id="2-5线程"><a href="#2-5线程" class="headerlink" title="2.5线程"></a>2.5线程</h2><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</p>
<p>引入线程之后，提高了系统的并发度</p>
<p>线程是处理机的分配单元，是调度的基本单位</p>
<p>线程几乎不拥有系统资源，切换线程的系统开销要小得多</p>
<p>线程的实现方式：</p>
<ul>
<li>用户级线程：由应用程序负责，在用户态下完成，对操作系统透明</li>
<li>内核级线程：由操作系统内核完成，在核心态下完成 ，对操作系统不透明</li>
<li>当两者结合时，操作系统也只以内核级线程数量为准</li>
</ul>
<p>多线程模型问题：</p>
<ul>
<li>多对一：开销小，效率高，无法并行</li>
<li>一对一：成本大，可并行</li>
<li>多对多：两者的折中</li>
</ul>
<h2 id="2-6处理机调度"><a href="#2-6处理机调度" class="headerlink" title="2.6处理机调度"></a>2.6处理机调度</h2><p>由于资源有限，因此需要决定任务进行的顺序，需要处理机调度</p>
<p>调度的三个层次：</p>
<ul>
<li>高级调度（作业调度）：从后备队列的作业中挑一个作业，分配内存等资源，并建立响应的进程，是辅存与内存间的调度，调入时创建PCB，调出时撤销PCB</li>
<li>中级调度（内存调度）：决定将哪个处于挂起状态的进程调入内存，可能反复调度多次某进程</li>
<li>低级调度（进程调度）：从就绪队列中选取一个进程，分配处理机，发生在内存到CPU</li>
</ul>
<h2 id="2-7进程调度"><a href="#2-7进程调度" class="headerlink" title="2.7进程调度"></a>2.7进程调度</h2><p>进程调度的时机：</p>
<ul>
<li>进程主动或被动放弃处理机时，需要进程调度</li>
<li>不能进行进程调度的情况：</li>
<li><ul>
<li>处理中断</li>
<li>进程在操作系统内核程序临界区中（注意不是普通的临界区）</li>
<li>原语操作中</li>
</ul>
</li>
</ul>
<p>进程切换过程：</p>
<ul>
<li>对原来运行的进程各种数据的保存</li>
<li>对新进程各种数据的恢复</li>
</ul>
<p>进程切换是有代价的</p>
<p>进程调度方式：</p>
<ul>
<li>非剥夺调度方式</li>
<li>剥夺调度方式</li>
</ul>
<h2 id="2-8调度算法的评价指标"><a href="#2-8调度算法的评价指标" class="headerlink" title="2.8调度算法的评价指标"></a>2.8调度算法的评价指标</h2><ul>
<li>CPU利用率=忙碌的时间/总时间</li>
<li>系统吞吐量=作业量/时间</li>
<li>周转时间=作业完成时间-作业提交时间</li>
<li>带权周转时间=作业周转时间/作业实际运行时间</li>
<li>等待时间：等待被服务的时间</li>
<li>响应时间：从用户提交请求到首次响应的时间</li>
</ul>
<h2 id="2-9调度算法"><a href="#2-9调度算法" class="headerlink" title="2.9调度算法"></a>2.9调度算法</h2><p>先来先服务（FCFS）</p>
<ul>
<li>非抢占、实现简单、对短作业不利、不会饥饿</li>
</ul>
<p>短作业优先（SJF）</p>
<ul>
<li>默认非抢占、最短的平均等待时间、对长作业不利、会导致饥饿、运行时间由用户提供不一定真实</li>
</ul>
<p>高响应比优先（HRRN）</p>
<ul>
<li>响应比=（等待时间+要求服务时间）/要求服务时间</li>
<li>非抢占、不会饥饿，是前两种算法折中的结果</li>
</ul>
<p>时间片轮转（RR）</p>
<ul>
<li>抢占、公平、切换频繁、不会饥饿</li>
</ul>
<p>优先级调度</p>
<ul>
<li>抢占或非抢占、可能饥饿</li>
</ul>
<p>多级反馈队列</p>
<ul>
<li>很复杂，是多种算法的平衡，可能导致饥饿</li>
</ul>
<h2 id="2-10进程同步与互斥"><a href="#2-10进程同步与互斥" class="headerlink" title="2.10进程同步与互斥"></a>2.10进程同步与互斥</h2><p>同步是进程间的直接制约关系</p>
<p>互斥是保护临界资源的必要原则</p>
<p>互斥的四个部分：进入区、临界区、退出区、剩余区</p>
<p>互斥原则：空闲让进、忙则等待、有限等待、让权等待</p>
<h2 id="2-11进程互斥的软件实现方法"><a href="#2-11进程互斥的软件实现方法" class="headerlink" title="2.11进程互斥的软件实现方法"></a>2.11进程互斥的软件实现方法</h2><p>单标志法：在完全访问完临界区后将临界区权限转交给另一进程，即权限链式赋予，但是违背“空闲让进”原则</p>
<p>双标志先检查法：先检查一遍其他进程的意愿，违背“忙则等待”原则</p>
<p>双标志后检查法：先上锁后检查，违背”空闲让进“和”有限等待“，产生饥饿</p>
<p>Peterson算法：主动谦让，最后一个说客气话的循环等待，违背“让权等待”原则</p>
<h2 id="2-12进程互斥的硬件实现方法"><a href="#2-12进程互斥的硬件实现方法" class="headerlink" title="2.12进程互斥的硬件实现方法"></a>2.12进程互斥的硬件实现方法</h2><p>中断屏蔽方法：利用“开/关中断指令实现，简单高效，只适用于单处理机，只适用于内核进程</p>
<p>TestAndSet：违背”让权等待“，实现简单，适用于多处理机</p>
<p>Swap指令：违背”让权等待“，实现简单，适用于多处理机</p>
<h2 id="2-13信号量机制"><a href="#2-13信号量机制" class="headerlink" title="2.13信号量机制"></a>2.13信号量机制</h2><p>整型信号量：违背“让权等待”，PV操作</p>
<p>记录型信号量：遵循“让权等待”，PV操作、block和wakeup</p>
<h2 id="2-14信号量机制实现"><a href="#2-14信号量机制实现" class="headerlink" title="2.14信号量机制实现"></a>2.14信号量机制实现</h2><p>实现进程互斥：</p>
<ul>
<li>划定临界区</li>
<li>设置互斥信号量，初值为1</li>
<li>临界区前执行P</li>
<li>临界区后执行V</li>
</ul>
<p>注意：对不同的临界资源需要设置不同的互斥信号量</p>
<p>实现进程同步：</p>
<ul>
<li>设置同步信号量，初值为0</li>
<li>前操作之后执行V</li>
<li>后操作之前执行P</li>
</ul>
<p>实现前驱关系：多个同步问题叠加</p>
<h2 id="2-15生产者消费者问题"><a href="#2-15生产者消费者问题" class="headerlink" title="2.15生产者消费者问题"></a>2.15生产者消费者问题</h2><p>一个互斥量控制访问，两个同步量控制产品数和空位数</p>
<p>注意实现互斥的P一定要在实现同步的P之后</p>
<p>而两个V操作的顺序可以互换</p>
<h2 id="2-16多生产者多消费者问题"><a href="#2-16多生产者多消费者问题" class="headerlink" title="2.16多生产者多消费者问题"></a>2.16多生产者多消费者问题</h2><p>若缓冲区容量为1，一般可省去互斥量</p>
<h2 id="2-17吸烟者问题"><a href="#2-17吸烟者问题" class="headerlink" title="2.17吸烟者问题"></a>2.17吸烟者问题</h2><p>生产者消费者问题变种，注意缓冲区为1</p>
<h2 id="2-18读者写者问题"><a href="#2-18读者写者问题" class="headerlink" title="2.18读者写者问题"></a>2.18读者写者问题</h2><p>核心思想是设置了一个计数器来记录当前正在访问共享文件的读进程数</p>
<p>对计数器的检查和赋值不能同时进行会引入错误，可用互斥信号量来解决</p>
<h2 id="2-19哲学家进餐问题"><a href="#2-19哲学家进餐问题" class="headerlink" title="2.19哲学家进餐问题"></a>2.19哲学家进餐问题</h2><p>解决死锁</p>
<p>三种思路：</p>
<ul>
<li>减少抢占资源的最大人数</li>
<li>事先规定每个人的抢占顺序</li>
<li>抢占资源前先判断能否拿到所有资源</li>
</ul>
<h2 id="2-20管程"><a href="#2-20管程" class="headerlink" title="2.20管程"></a>2.20管程</h2><p>管程结构：</p>
<ul>
<li>局部于管程的共享数据结构</li>
<li>对该数据结构进行操作的一组函数</li>
<li>对局部于管程的共享数据结构设置初始值的语句</li>
<li>管程有一个名字</li>
</ul>
<p>管程的基本特征：</p>
<ul>
<li>局部于管程的数据只能被局部于管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li>每次仅允许一个进程在管程内执行某个内部过程</li>
</ul>
<h2 id="2-21死锁的概念"><a href="#2-21死锁的概念" class="headerlink" title="2.21死锁的概念"></a>2.21死锁的概念</h2><ul>
<li>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法推进</li>
<li>饥饿：由于长期得不到资源，导致进程无法推进</li>
<li>死循环：进程执行中一直无法跳出循环</li>
</ul>
<p>死锁的必要条件：</p>
<ul>
<li>互斥</li>
<li>不剥夺</li>
<li>请求和保持</li>
<li>循环等待</li>
</ul>
<p>什么时候回发生死锁：</p>
<ul>
<li>对不可剥夺资源的竞争（如打印机）</li>
<li>进程推进顺序非法，请求和释放资源的顺序不当</li>
<li>信号量的使用不当</li>
</ul>
<p>死锁的处理策略：</p>
<ul>
<li>预防死锁，破坏死锁的必要形成条件</li>
<li>避免死锁：防止系统进入不安全状态（银行家算法）</li>
<li>死锁的检测和解除：操作系统检查出死锁的发生，然后采取措施</li>
</ul>
<h2 id="2-22死锁的处理策略——预防死锁"><a href="#2-22死锁的处理策略——预防死锁" class="headerlink" title="2.22死锁的处理策略——预防死锁"></a>2.22死锁的处理策略——预防死锁</h2><ul>
<li>破坏互斥：将互斥资源改造为共享资源，如SPOOLing技术</li>
<li>破坏不剥夺：主动放弃已有资源或强行剥夺其他资源，但可能会导致饥饿，增加系统开销，会导致已有工作失效</li>
<li>破坏请求与保持：静态分配，一次分配所需资源，会导致饥饿，效率低</li>
<li>破坏循环等待：预先指定请求资源的顺序，不方便增加设备，资源浪费，编程复杂</li>
</ul>
<h2 id="2-23死锁的处理策略——避免死锁"><a href="#2-23死锁的处理策略——避免死锁" class="headerlink" title="2.23死锁的处理策略——避免死锁"></a>2.23死锁的处理策略——避免死锁</h2><p>银行家算法：</p>
<ul>
<li>检查申请是否超过了之前声明的最大需求数</li>
<li>检查此时系统剩余的可用资源是否能满足这次请求</li>
<li>试探着分配，更改各数据</li>
<li>用安全性算法检查分配是否会导致系统进入不安全状态</li>
</ul>
<p>安全性算法：检查当前的剩余可用资源是否能够满足某个进程的最大需求，如果可以，就把进程加入安全队列，并把该进程的所有资源全部回收。不断重复这一过程，看最终是否能让所有进程都加入安全序列</p>
<p>系统处于不安全状态不一定会死锁，处于安全状态一定不会死锁</p>
<h2 id="2-24死锁的处理策略——检测和解除"><a href="#2-24死锁的处理策略——检测和解除" class="headerlink" title="2.24死锁的处理策略——检测和解除"></a>2.24死锁的处理策略——检测和解除</h2><p>检测：资源分配图的削边法，依次消除与不阻塞进程相连的边，最后连着边的进程就是死锁进程</p>
<p>解除：对死锁进程进行资源剥夺、撤销或回退</p>
<h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3.内存管理"></a>3.内存管理</h1><h2 id="3-1内存的基础知识"><a href="#3-1内存的基础知识" class="headerlink" title="3.1内存的基础知识"></a>3.1内存的基础知识</h2><p>从写程序到程序运行：编译$\rightarrow$  链接$\rightarrow$ 装入</p>
<p>三种装入方式：</p>
<ul>
<li>绝对装入：在编译时就知道程序在内存中的位置，只适用于单道程序环境</li>
<li>静态重定位：根据装入的起始位置计算物理地址，装入时必须分配所有内存空间，在运行期间不能移动</li>
<li>动态重定位：使用重定位寄存器，允许程序在内存中发生移动</li>
</ul>
<p>三种链接方式：</p>
<ul>
<li>静态链接：先链接后装入</li>
<li>装入时动态链接：边装入边链接</li>
<li>运行时动态链接：需要执行时才进行链接，便于修改和更新，便于实现对目标模块的共享</li>
</ul>
<h2 id="3-2内存管理的概念"><a href="#3-2内存管理的概念" class="headerlink" title="3.2内存管理的概念"></a>3.2内存管理的概念</h2><ul>
<li>操作系统负责内存空间的分配与回收</li>
<li>操作系统需要从逻辑上对内存空间进行扩充</li>
<li>操作系统需要提供地址转换功能</li>
<li>操作系统需要提供内存保护功能</li>
</ul>
<p>内存保护的两种方式：设置上下限寄存器、界地址寄存器</p>
<h2 id="3-3覆盖与交换"><a href="#3-3覆盖与交换" class="headerlink" title="3.3覆盖与交换"></a>3.3覆盖与交换</h2><p>覆盖技术：程序大小超过内存总和，使用覆盖技术，将不常用的程序段放在覆盖区，对用户不透明，已弃用</p>
<p>交换技术：内存紧张时，换出某些进程，换出的进程放在对换区（I/O速度比文件区快）</p>
<p>区别：覆盖是在同一个进程中的，交换是不同进程之间的</p>
<h2 id="3-4连续分配管理方式"><a href="#3-4连续分配管理方式" class="headerlink" title="3.4连续分配管理方式"></a>3.4连续分配管理方式</h2><p>单一连续分配：只支持单道程序，用户程序放在用户区，无外部碎片，有内部碎片</p>
<p>固定分区分配：支持多道程序，每个分区只能装一道作业，无外部碎片，有内部碎片，有分区大小相等和不等两种方式</p>
<p>动态分区分配：动态建立分区，无内部碎片，有外部碎片</p>
<p>用于管理空闲分区的数据结构——空闲分区表、空闲分区链</p>
<h2 id="3-5动态分区分配算法"><a href="#3-5动态分区分配算法" class="headerlink" title="3.5动态分区分配算法"></a>3.5动态分区分配算法</h2><ul>
<li>首次适应：从头到尾找适合的分区，算法开销小，综合性能最好</li>
<li>最佳适应：优先使用更小的分区，算法开销大，产生大量小碎片</li>
<li>最坏适应：优先使用更大的，算法开销大，不利于大进程</li>
<li>邻近适应：从上次查找结束位置开始查找，算法开销小，但会使高地址的大分区也被用完</li>
</ul>
<h2 id="3-6基本分页存储管理的概念"><a href="#3-6基本分页存储管理的概念" class="headerlink" title="3.6基本分页存储管理的概念"></a>3.6基本分页存储管理的概念</h2><p>思想：把进程分页，各个页面离散地放到内存块中</p>
<p>概念：页框、页、页号</p>
<p>实现地址转换：</p>
<ul>
<li>计算出逻辑地址对应的页号</li>
<li>找到对应页面在内存中的位置</li>
<li>算出页内偏移量</li>
<li>物理地址=页面地址+页内偏移量</li>
</ul>
<p>计算：页号=逻辑地址/页面大小；页内偏移量=逻辑地址%页面大小</p>
<p>页表：</p>
<ul>
<li>页表记录进程页面和实际存放的内存块之间的对应关系</li>
<li>一个进程对应一张页表，进程的每一页对应一个页表项，页表项由页号和块号组成</li>
<li>每个页表项的长度是相同的，页号是隐含的</li>
</ul>
<h2 id="3-7基本地址变换机构"><a href="#3-7基本地址变换机构" class="headerlink" title="3.7基本地址变换机构"></a>3.7基本地址变换机构</h2><p>页表寄存器的作用：存放页表起始地址，存放页表长度</p>
<p>地址变换过程：</p>
<ul>
<li>根据逻辑地址算出页号、页内偏移量</li>
<li>页号的合法性检查</li>
<li>若页号合法，再根据页表起始地址、页号找到对应页表项</li>
<li>根据页表项中的内存块号、页内偏移量得到最终的物理地址</li>
<li>访问存储单元</li>
</ul>
<p>小细节：</p>
<ul>
<li>页内偏移量与页面大小的关系</li>
<li>页式管理中地址是一维的</li>
<li>实际应用中，通常使一个页框恰好能放入整数个页表项</li>
<li>为了方便找到页表项，页表一般是放在连续的内存块中的</li>
</ul>
<h2 id="3-8具有快表的地址变换机构"><a href="#3-8具有快表的地址变换机构" class="headerlink" title="3.8具有快表的地址变换机构"></a>3.8具有快表的地址变换机构</h2><p>地址变换过程：</p>
<ul>
<li>根据逻辑地址算出页号、页内偏移量</li>
<li>页号的合法性检查</li>
<li>查快表，若命中则跳过查页表</li>
<li>查页表，再根据页表起始地址、页号找到对应页表项，并将页表项复制到快表中</li>
<li>根据页表项中的内存块号、页内偏移量得到最终的物理地址</li>
<li>访问存储单元</li>
</ul>
<p>快表命中，则访存一次；未命中，则访存两次</p>
<h2 id="3-9基本分段存储管理方式"><a href="#3-9基本分段存储管理方式" class="headerlink" title="3.9基本分段存储管理方式"></a>3.9基本分段存储管理方式</h2><p>段表中还含有段长</p>
<p>地址变换时，还需考虑段内地址是否越界</p>
<p>分页VS分段：</p>
<ul>
<li>分页对用户不可见，分段对用户可见</li>
<li>分页的地址空间是一维的，分段的地址空间是二维的</li>
<li>分段更容易实现信息的共享和保护</li>
<li>分页与分段访问一个逻辑地址都需要两次访存，分段存储也可引入快表</li>
</ul>
<h2 id="3-10段页式管理方式"><a href="#3-10段页式管理方式" class="headerlink" title="3.10段页式管理方式"></a>3.10段页式管理方式</h2><p>分页难以实现信息的共享和保护，分段会产生外部碎片</p>
<p>段表需存储页表长度和页表存放地址</p>
<p>地址变换时需要检查页号是否越界</p>
<p>访存三次：查段表、查页表、访问目标单元</p>
<p>可引入快表机构，以段号和页号为关键字查询快表，命中时仅需一次访存</p>
<h2 id="3-11虚拟内存的基本概念"><a href="#3-11虚拟内存的基本概念" class="headerlink" title="3.11虚拟内存的基本概念"></a>3.11虚拟内存的基本概念</h2><p>特征：多次性、对换性、虚拟性</p>
<p>建立在离散分配的基础上</p>
<h2 id="3-12请求分页管理方式"><a href="#3-12请求分页管理方式" class="headerlink" title="3.12请求分页管理方式"></a>3.12请求分页管理方式</h2><p>在基本分页的基础上增加了几个表项：</p>
<ul>
<li>状态位：页面是否已在内存中</li>
<li>访问字段：记录最近被访问过几次，或记录上次访问的时间</li>
<li>修改位：表示页面调入内存后是否被修改过，只有修改过的页面才需在置换时写回外存</li>
<li>外存地址：页面在外存中的地址</li>
</ul>
<p>缺页中断机构：</p>
<ul>
<li>找到页表项后检查页面是否已经在内存，若没在内存，产生缺页中断</li>
<li>缺页中断处理中，需要将目标页面调入内存，有必要时还要换出页面</li>
<li>缺页中断属于内中断的“故障”，即可能被系统修复的异常</li>
<li>一条指令在执行过程中可能产生多次缺页中断</li>
</ul>
<p>地址变换机构：</p>
<ul>
<li>找到页表项需要检查页面是否在内存中</li>
<li>若页面不在内存中，需要请求调页</li>
<li>若内存空间不够，需要换出页面</li>
<li>页面调出内存后，需要修改相应页表项</li>
</ul>
<h2 id="3-13页面置换算法"><a href="#3-13页面置换算法" class="headerlink" title="3.13页面置换算法"></a>3.13页面置换算法</h2><ul>
<li>OPT：优先淘汰最长时间内不会被访问的页面，缺页率最小，但无法实现</li>
<li>FIFO：优先淘汰最先进入内存的页面，实现简单，可能出现Belady异常（增大块数反而缺页次数增加）</li>
<li>LRU：优先淘汰最近最久没访问的页面，性能很好，但是算法开销大</li>
<li>CLOCK：循环扫描各页面，扫0，开销小，但是没有考虑页面是否被修改</li>
<li>改进型CLOCK：四轮淘汰：（0,0），（0,1）且将扫描过的页面访问位置0，（0,0），（0,1），算法开销小，性能也不错</li>
</ul>
<h2 id="3-14页面分配策略"><a href="#3-14页面分配策略" class="headerlink" title="3.14页面分配策略"></a>3.14页面分配策略</h2><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合</p>
<p>固定分配局部置换：缺页时换出进程自己的某页</p>
<p>可变分配全局置换：只要缺页就分配新物理块</p>
<p>可变分配局部置换：根据缺页率动态分配物理块</p>
<p>何时调入页面：</p>
<ul>
<li>预调页策略：一般用于进程运行前</li>
<li>请求调页策略：进程运行时，发现缺页再调页</li>
</ul>
<p>从何处调页：</p>
<ul>
<li>对换区——采用连续存储，速度快；文件区——采用离散存储，速度慢</li>
<li>对换区够大：运行时将数据从文件区复制到对换区</li>
<li>对换区不够大：不会修改的数据每次都从文件区调入，会修改的数据调出到对换区，需要时再调入</li>
<li>UNIX方式：第一次使用的页面都从文件区调入，调回的页面都写回对换区，再次使用时从对换区调入</li>
</ul>
<p>抖动（颠簸）现象：页面平凡换入换出，主要原因是分配给进程的物理块不够</p>
<p>工作集：在某段时间间隔里，进程实际访问页面的集合，驻留集大小一般不能小于工作集大小</p>
<h1 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4.文件管理"></a>4.文件管理</h1><h2 id="4-1文件的逻辑结构"><a href="#4-1文件的逻辑结构" class="headerlink" title="4.1文件的逻辑结构"></a>4.1文件的逻辑结构</h2><p>无结构文件：由二进制或字符流组成，无明显的逻辑结构</p>
<p>有结构文件：由记录组成，分为定长记录、可变长记录</p>
<p>顺序文件：</p>
<ul>
<li>分为串结构和顺序结构</li>
<li>可变长记录的顺序文件无法实现随机存取，定长记录可以</li>
<li>定长记录、顺序结构的顺序文件可以快速检索（根据关键字快速找到记录）</li>
<li>最大缺点：不方便增加/删除</li>
</ul>
<p>索引文件：</p>
<ul>
<li>建立一张索引表，每个记录对应一个表项</li>
<li>索引表本身是定长的顺序文件，索引文件支持随机存取</li>
<li>索引表若按关键字顺序排列，则可实现快速检索</li>
<li>索引表可能占用很多空间</li>
</ul>
<p>索引顺序文件：</p>
<ul>
<li>将记录分组，每组对应一个索引表项</li>
<li>检索记录时先顺序检查索引表，找到分组，再顺序查找分组</li>
<li>记录过多时，可建立多级索引表</li>
</ul>
<h2 id="4-2文件目录"><a href="#4-2文件目录" class="headerlink" title="4.2文件目录"></a>4.2文件目录</h2><p>文件目录项FCB包含了文件的基本信息、存取控制信息、使用信息</p>
<ul>
<li>单级目录结构：不允许文件重名</li>
<li>两级目录结构：不同用户的文件可以重名，不能分类</li>
<li>多级（树形）目录结构：不方便文件共享，使用相对路径可以减少I/O操作</li>
<li>无环图目录结构：共享节点的技术器为0时才真正删除该节点</li>
</ul>
<p>索引节点：除了文件名之外的其他信息都放到索引节点中，每个文件对应一个索引节点，每个磁盘块可以放更多目录项，检索文件时磁盘I/O的次数减少</p>
<h2 id="4-3文件物理结构"><a href="#4-3文件物理结构" class="headerlink" title="4.3文件物理结构"></a>4.3文件物理结构</h2><p>顺序分配：</p>
<ul>
<li>顺序存取速度快，支持随机访问</li>
<li>会产生碎片</li>
</ul>
<p>隐式链接：</p>
<ul>
<li>可解决碎片问题，外存利用率高，文件拓展实现方便</li>
<li>只能顺序访问，不能随机存取</li>
</ul>
<p>显示链接：</p>
<ul>
<li>除了隐式链接的优点，还能实现随机访问</li>
<li>FAT（文件分配表）需要占用空间</li>
</ul>
<p>索引分配：</p>
<ul>
<li>支持随机访问，易实现文件拓展</li>
<li>索引表占用空间，可能需要多次读磁盘</li>
</ul>
<h2 id="4-4文件存储空间管理"><a href="#4-4文件存储空间管理" class="headerlink" title="4.4文件存储空间管理"></a>4.4文件存储空间管理</h2><ul>
<li>空闲表法：记录每个连续空闲区的起始盘块号、盘块数</li>
<li>空闲链表法：分为空闲盘块链和空闲盘区链</li>
<li>位示图法：一个二进制位代表一个盘块</li>
<li>成组链接法：UNIX采用的策略</li>
</ul>
<h2 id="4-5文件的基本操作"><a href="#4-5文件的基本操作" class="headerlink" title="4.5文件的基本操作"></a>4.5文件的基本操作</h2><p>打开文件：</p>
<ul>
<li>将目录项中的信息复制到内存中的打开文件表中，并将打开文件表的索引号返回给用户</li>
<li>每个进程有自己的打开文件表，系统也有一张总的打开文件表</li>
</ul>
<h2 id="4-6文件共享"><a href="#4-6文件共享" class="headerlink" title="4.6文件共享"></a>4.6文件共享</h2><p>分为硬链接和软链接</p>
<p>硬链接：各个用户的目录项指向同一个索引节点，需要链接计数count</p>
<p>软链接：在一个Link型的文件中记录共享文件的存放路径，访问速度较慢，有查询失败的可能</p>
<h2 id="4-7文件保护"><a href="#4-7文件保护" class="headerlink" title="4.7文件保护"></a>4.7文件保护</h2><p>口令保护：为文件设置口令，但是不安全</p>
<p>加密保护：用密码对文件进行加密，安全性高，但是耗费时间</p>
<p>访问控制：用访问控制表（ACL）来记录各个用户对文件的访问权限</p>
<h2 id="4-8文件系统的层次结构"><a href="#4-8文件系统的层次结构" class="headerlink" title="4.8文件系统的层次结构"></a>4.8文件系统的层次结构</h2><p>用户接口、文件目录系统、存取控制模块、逻辑文件系统与文件信息缓冲区、物理文件系统、设备管理程序模块、辅助分配模块</p>
<h2 id="4-9磁盘的结构"><a href="#4-9磁盘的结构" class="headerlink" title="4.9磁盘的结构"></a>4.9磁盘的结构</h2><p>磁盘、磁道、扇区、盘面、柱面</p>
<p>磁盘的物理地址：柱面号、盘面号、扇区号</p>
<p>磁盘的分类：固定头磁盘、移动头磁盘、固定盘磁盘、可更换磁盘</p>
<h2 id="4-10磁盘调度算法"><a href="#4-10磁盘调度算法" class="headerlink" title="4.10磁盘调度算法"></a>4.10磁盘调度算法</h2><p>一次磁盘读写操作需要的时间：寻找时间+延迟时间+传输时间</p>
<ul>
<li>先来先服务算法（FCFS）：根据进程请求顺序进行调度</li>
<li>最短寻找时间优先（SSTF）：优先处理与当前磁头最近的磁道，可能产生饥饿现象</li>
<li>扫描算法（SCAN）：磁头来回扫描，不会产生饥饿现象，但是对各个磁道响应频率不平均</li>
<li>LOOK调度算法：边移动边观察，若行进方向上没有请求就掉头，减少了寻道时间</li>
<li>循环扫描算法（C-SCAN）：在SCAN的基础上，到头后立即返回至起始端，响应平均但寻道时间增加了</li>
<li>C-LOOK调度算法：在C-SCAN的基础上，返回到最远的请求出即可</li>
</ul>
<h2 id="4-11减少磁盘延迟时间"><a href="#4-11减少磁盘延迟时间" class="headerlink" title="4.11减少磁盘延迟时间"></a>4.11减少磁盘延迟时间</h2><p>交替编号：让编号相邻的扇区在物理上不相邻</p>
<p>错位命名：让相邻盘面的扇区编号错位</p>
<p>为什么用（柱面号、盘面号、扇区号）的结构，而不用（盘面号、柱面号、扇区号）的结构？</p>
<p>原因：在读取地址连续的磁盘块时，前者不需要移动磁头</p>
<h2 id="4-12磁盘的管理"><a href="#4-12磁盘的管理" class="headerlink" title="4.12磁盘的管理"></a>4.12磁盘的管理</h2><p>磁盘初始化：</p>
<ul>
<li>低级格式化：划分扇区</li>
<li>磁盘分区</li>
<li>逻辑格式化：建立文件系统</li>
</ul>
<p>引导块：ROM中放入自举装入程序，完整的自举程序放在引导块中</p>
<p>坏块的管理：</p>
<ul>
<li>简单磁盘：逻辑格式化时将坏块标记出来</li>
<li>复杂磁盘：磁盘控制器维护一个坏块链，并管理备用扇区</li>
</ul>
<h1 id="5-I-O管理"><a href="#5-I-O管理" class="headerlink" title="5.I/O管理"></a>5.I/O管理</h1><h2 id="5-1I-O设备的基本概念与分类"><a href="#5-1I-O设备的基本概念与分类" class="headerlink" title="5.1I/O设备的基本概念与分类"></a>5.1I/O设备的基本概念与分类</h2><p>按信息交换的单位分类：</p>
<ul>
<li>块设备：传输快，可寻址</li>
<li>字符设备：传输慢，不可寻址，常采用中断驱动方式 </li>
</ul>
<h2 id="5-2I-O控制器"><a href="#5-2I-O控制器" class="headerlink" title="5.2I/O控制器"></a>5.2I/O控制器</h2><p>主要功能：</p>
<ul>
<li>接受和识别CPU的命令（控制寄存器）</li>
<li>向CPU报告设备的状态（状态寄存器）</li>
<li>数据交换（数据寄存器）</li>
<li>地址识别（I/O逻辑）</li>
</ul>
<p>组成：</p>
<ul>
<li>CPU与控制器之间的接口</li>
<li>I/O逻辑</li>
<li>控制器与设备之间的接口</li>
</ul>
<p>两种寄存器编址方式：</p>
<ul>
<li>内存映射I/O：控制器中的寄存器与内存统一编址，可采用对内存进行操作的指令对控制器进行操作</li>
<li>寄存器独立编址：控制器中的寄存器独立编址，需要设置专门的指令来操作控制器</li>
</ul>
<h2 id="5-3I-O控制方式"><a href="#5-3I-O控制方式" class="headerlink" title="5.3I/O控制方式"></a>5.3I/O控制方式</h2><p>程序直接控制方式：CPU发出I/O命令后需要不断轮询</p>
<p>中断驱动方式：CPU发出命令后可以做其他事，I/O完成后设备控制器发出中断信号</p>
<p>DMA方式：传输块，跳开CPU，由DMA控制器发出中断信号</p>
<p>通道控制方式：传输一组块</p>
<h2 id="5-4I-O软件层次结构"><a href="#5-4I-O软件层次结构" class="headerlink" title="5.4I/O软件层次结构"></a>5.4I/O软件层次结构</h2><p>从用户到硬件：</p>
<ul>
<li>用户层软件：与用户交互，提供库函数</li>
<li>设备独立性软件：向上提供调用接口，设备的保护，差错处理，设备的分配与回收，数据缓冲区管理，建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用响应的驱动程序</li>
<li>设备驱动程序：设置设备寄存器，检查设备状态</li>
<li>中断处理程序：进行中断处理</li>
<li>硬件：执行I/O操作</li>
</ul>
<h2 id="5-5I-O核心子系统"><a href="#5-5I-O核心子系统" class="headerlink" title="5.5I/O核心子系统"></a>5.5I/O核心子系统</h2><p>设备独立性软件、设备驱动软件、中断处理程序</p>
<h2 id="5-6假脱机技术"><a href="#5-6假脱机技术" class="headerlink" title="5.6假脱机技术"></a>5.6假脱机技术</h2><p>脱机技术：缓解设备与CPU的速度矛盾，实现预输入，缓输出</p>
<p>假脱机技术：软件方式模拟脱机技术，通过输入井和输出井、输入缓冲区和输出缓冲区模拟，相当于建立中转站</p>
<h2 id="5-7设备的分配与回收"><a href="#5-7设备的分配与回收" class="headerlink" title="5.7设备的分配与回收"></a>5.7设备的分配与回收</h2><p>设备分配管理中的数据结构：</p>
<ul>
<li>设备控制表DCT</li>
<li>控制器控制表COCT</li>
<li>通道控制表CHCT</li>
<li>系统控制表SDT</li>
</ul>
<p>设备分配：</p>
<ul>
<li>根据进程请求的物理设备名查找SDT</li>
<li>根据SDT查找DCT并分配设备</li>
<li>根据DCT查找COCT并分配控制器</li>
<li>根据COCT查找CHCT并分配通道</li>
</ul>
<p>缺点：必须使用物理设备名，若物理设备更换则程序无法运行，同类设备也会出现阻塞问题</p>
<p>改进：使用逻辑设备名，操作系统负责实现映射（逻辑设备表）</p>
<p>逻辑设备表（LUT）设置：</p>
<ul>
<li>整个系统只有一张LUT，适用于单用户操作系统</li>
<li>每个用户一张LUT，适用于多用户操作系统</li>
</ul>
<h2 id="5-8缓冲区管理"><a href="#5-8缓冲区管理" class="headerlink" title="5.8缓冲区管理"></a>5.8缓冲区管理</h2><p>单缓冲</p>
<ul>
<li>处理平均耗时：Max（C，T）+M</li>
</ul>
<p>双缓冲</p>
<ul>
<li>处理平均耗时：Max（T，C+M）</li>
</ul>
<p>循环缓冲</p>
<ul>
<li>多个缓冲区链接成循环队列，in指针指向第一个空缓冲区，out指针指向第一个满缓冲区</li>
</ul>
<p>缓冲池</p>
<ul>
<li>三个队列：空缓冲队列、输入队列、输出队列</li>
<li>四个缓冲区：收容输入数据、提取输入数据、收容输出数据、提取输出数据</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="ckct9hun10000m0v27yzfcjmc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/07/18/%E5%8D%9A%E5%AE%A2%E5%85%A5%E9%97%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">博客入门</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
          </li>
        
          <li>
            <a href="/2020/07/18/%E5%8D%9A%E5%AE%A2%E5%85%A5%E9%97%A8/">博客入门</a>
          </li>
        
          <li>
            <a href="/2020/07/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>