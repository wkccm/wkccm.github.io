<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-MySQL知识点归纳" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/25/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" class="article-date">
  <time datetime="2020-07-25T05:43:33.894Z" itemprop="datePublished">2020-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/25/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">MySQL知识点归纳</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="P1"><a href="#P1" class="headerlink" title="P1"></a>P1</h1><p>数据库的好处：</p>
<ul>
<li>持久化数据到本地</li>
<li>可以实现结构化查询，方便管理</li>
</ul>
<p>数据库相关概念：</p>
<ul>
<li>DB：数据库，保存一组有组织的数据的容器</li>
<li>DBMS：数据库管理系统，即数据库软件，用于管理</li>
<li>SQL：结构化查询语言，与DBMS沟通的语言</li>
</ul>
<p>数据库的特点：</p>
<ul>
<li>数据放到表中，表再放到库中</li>
<li>一个数据库可以有多个表，每个表都有自己的名字，有唯一性</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储</li>
<li>表由列组成</li>
<li>表中的数据按行存储</li>
</ul>
<p>MySQL优点：</p>
<ul>
<li>成本低，开源</li>
<li>性能快</li>
<li>安装简单</li>
</ul>
<p>DBMS分类：</p>
<ul>
<li>基于共享文件系统的DBMS</li>
<li>基于客户机——服务器的DBMS</li>
</ul>
<p>MySQL服务的登录和退出</p>
<ul>
<li>方式一：通过mysql自带的客户端</li>
<li>方式二：通过windows客户端，mysql 【-h主机名 -P端口号】-u用户名 -p密码</li>
<li>退出：exit或Ctrl+C</li>
</ul>
<p>MySQL的常见命令：</p>
<ul>
<li>查看当前所有数据库：show database</li>
<li>打开指定的库：use 库名</li>
<li>查看当前库的所有表：show tables</li>
<li>查看其他库的所有表：show tables from 库名</li>
<li>创建表：create table 表名（列名 列类型，列名 列类型）；</li>
<li>查看表结构：desc 表名</li>
<li>查看服务器版本：在内部select version（）；在外部mysql –version或mysql -V</li>
</ul>
<p>MySQL语法规范：</p>
<ul>
<li>不区分大小写，但建议关键字大写，表名、列名小写</li>
<li>每行命令最好用分号结尾</li>
<li>可以根据需要缩进和换行</li>
<li>注释：单行注释#或–空格；多行注释/* */</li>
</ul>
<h1 id="P2"><a href="#P2" class="headerlink" title="P2"></a>P2</h1><p>基础查询：select 查询列表 from 表名</p>
<p>基础查询全部：select * from 表名</p>
<p>查询常量值：select 常量</p>
<p>查询函数：select version()</p>
<p>起别名：select 内容 as 别名，as可用空格替代</p>
<p>去重：select distinct XXX from XXX</p>
<p>MySQL中+号的功能：只能作运算符</p>
<ul>
<li>当其中一方为字符型时，首先将字符型转化为数值型</li>
<li>如果转换成功，则继续做加法运算</li>
<li>如果转换失败，则将字符型数值转换为0</li>
<li>只要其中一方为null，则结果肯定为null</li>
</ul>
<p>拼接：select concat（XXX，XXX）as 别名</p>
<p>判断函数： ifnull（A，B）若A是null则返回B</p>
<p>条件查询：</p>
<ul>
<li>select 查询列表 from 表名 where 筛选条件</li>
<li>按条件表达式筛选</li>
<li>按逻辑表达式筛选</li>
<li>模糊查询</li>
<li><ul>
<li>like：与通配符一起使用（%任意多个字符，_任意单个字符，配合转义\使用）可以自己设置转义字符（后面加escape 转义字符）</li>
<li>between and：在XXX与XXX之间，包含临界值，临界值不能颠倒</li>
<li>in：in（XXX，XXX）属于列表中的某一项，不支持通配符</li>
<li>is null/is not null：判断是否为null（等号是判断不了的）补充：安全等于&lt;=&gt;两者均可</li>
</ul>
</li>
</ul>
<h1 id="P3"><a href="#P3" class="headerlink" title="P3"></a>P3</h1><p>排序查询：select 查询列表 from表 【where 筛选条件】order by 排序列表 asc/desc（若不写，默认升序）可以按表达式、函数、多个字段排序，一般放在查询语句的最后面（limit除外）</p>
<p>字符函数：length获取参数值的字节个数</p>
<p>拼接字符串：concat</p>
<p>upper、lower：变大小写</p>
<p>substr、substring：截取字符串（MySQL中索引从1开始）</p>
<ul>
<li>select substr（XXX，a）从索引a处截取后面所有长度</li>
<li>select substr（XXX，a，b）从a截取到b</li>
</ul>
<p>instr：返回子串第一次出现的索引instr（XXX，a）</p>
<p>trim：移除前后的目标子串：trim（a from XXX）</p>
<p>lpad：左填充lpad（XXX，a，X）用X填到长度为a</p>
<p>rpad：右填充</p>
<p>replace：替换replace（XXX，a，b）将a替换为b</p>
<p>round：</p>
<ul>
<li>四舍五入取整round（X）</li>
<li>四舍五入到小数点后a位round（X，a）</li>
</ul>
<p>ceil：向上取整</p>
<p>floor：向下取整</p>
<p>truncate：截断到小数点后a位truncate（XXX，a）</p>
<p>mod：取余，余数符号与被除数一致</p>
<p>now：返回当前系统日期+时间</p>
<p>curdate：返回当前系统日期、不包含时间</p>
<p>curtime：返回当前时间、不包含日期</p>
<p>select year（now（））：获取指定部分</p>
<p>str_to_date：将日期格式的字符转成日期</p>
<p>select str_to_date（‘1998-3-2’，‘%Y-%c-%d’）</p>
<p>date_format（now（），‘XXX’）将日期转换成字符</p>
<p>select databases（）查看当前数据库</p>
<p>select user（）查看用户</p>
<p>select if（X，a，b）若X成立则a，否则为b</p>
<p>分支判等：case 要判断的字段或表达式when 常量1 then 显示的值或语句 else显示的值或语句 end</p>
<p>分支条件：case when条件1 then显示的值或语句else显示的值或语句end</p>
<p>sum求和、avg平均值、max最大值、min最小值、count计算个数</p>
<p>sum和avg忽略null值</p>
<h1 id="P4、5"><a href="#P4、5" class="headerlink" title="P4、5"></a>P4、5</h1><p>sum求和、avg平均值、max最大值、min最小值、count计算个数：都可以与distinct搭配实现去重</p>
<p>count （*）统计行数，可以统计所有不是全为null的行数</p>
<p>count （1）统计行数，可以统计所有不是全为null的行数</p>
<p>一般用count（*）计数</p>
<p>和分组函数一同查询的字段会截断</p>
<p>datediff （a，b）计算b经过多少天到a</p>
<p>group by分组查询，在where之后，order之前，后接having可以进行分组后的条件筛选</p>
<p>分组后筛选的筛选条件是分组后计算得到的结果</p>
<p>group by可以按多个字段进行分组，分组更细致</p>
<p>连接查询：又称多表查询，查询的字段来自多个表</p>
<p>笛卡尔乘积现象：行乘算，结果行数过多</p>
<p>解决笛卡尔乘积需要添加where条件（A.b=C.d）</p>
<p>为表起别名：</p>
<ul>
<li>提高了语句的简洁度</li>
<li>区分多个重名的字段</li>
<li>若为表起了别名，则查询的字段就不能使用原来的表名去限定</li>
</ul>
<p>n表连接至少需要n-1个连接条件</p>
<p>自连接：给表起多个别名</p>
<p>sql99语法：</p>
<ul>
<li>select查询列表 from表1 别名 【连接类型】join表2 别名on连接条件</li>
<li>内连接，连接类型为inner，inner可以省略</li>
<li>外连接的查询结果为主表中的所有记录，表中有匹配的，则显示匹配的值，若没有则显示null。左外连接，left join左边的是主表，right join右边的是主表，全外连接MySQL不支持</li>
<li>交叉连接cross join 笛卡尔积</li>
</ul>
<p>sql92 VS sql99：sql支持的较多，实现了连接条件和筛选条件的分离</p>
<h1 id="P6"><a href="#P6" class="headerlink" title="P6"></a>P6</h1><p>标量子查询：嵌套select</p>
<p>列子查询（多行子查询）</p>
<p>行子查询（结果集一行多列或多行多列）：当比较操作符相同时进行合并，具有局限性</p>
<p>select后的子查询只支持一行一列</p>
<p>from后面的子查询</p>
<p>exist相关子查询</p>
<p>分页查询：加在最后limit offset，size；offset要显示条目的起始索引（从0开始），size要显示的条目个数</p>
<p>执行先后顺序：</p>
<p>*<em>7  *</em>select 查询列表</p>
<p>*<em>1  *</em> from 表</p>
<p>*<em>2  *</em> 连接类型 join 表2</p>
<p>*<em>3  *</em> on连接条件</p>
<p>*<em>4  *</em> where 筛选条件</p>
<p>*<em>5  *</em> group by分组列表</p>
<p>*<em>6  *</em> having 分组后的筛选</p>
<p>*<em>8  *</em> order by 排序列表</p>
<p>*<em>9  *</em> limit 偏移，条目数</p>
<p>联合查询：将多条查询语句的结果合并成一个结果，查询1 union 查询2 union……，列数需要一致，会自动去重，union all可不去重</p>
<p>DML语言：数据操作语言，插入、删除、修改</p>
<p>插入语句一：insert into 表名（列名，……）values（值1，……）</p>
<ul>
<li>插入的值要与类型兼容</li>
<li>不可以为null的列必须插入值，可以为null的列可插入null或跳过或不写对应的列名</li>
<li>列的顺序可以调换</li>
<li>列数和值的个数必须相等</li>
<li>可以省略列名，默认顺序所有列</li>
</ul>
<p>插入语句二：insert into 表名 set A=a，B=b……</p>
<p>方法一VS方法二：</p>
<ul>
<li>方法一支持插入多行，方法二不支持</li>
<li>方法一支持子查询，方法二不支持</li>
</ul>
<h1 id="P7"><a href="#P7" class="headerlink" title="P7"></a>P7</h1><p>修改语句：</p>
<ul>
<li>修改单表的内容：update 表名 set 列=新值，……where 筛选条件</li>
<li>修改多表的内容：update 表名1 别名 join 表2 别名 on连接条件 set A=a …… where 筛选条件</li>
</ul>
<p>删除：</p>
<ul>
<li>单表删除 delete from 表名 where 筛选条件</li>
<li>清空整张表 truncate table 表名</li>
<li>删除多表 delete 表名 from 表1 join 表2 on 连接条件where 筛选条件</li>
<li>delete删除后插入数据，自增值从断点开始，truncate从1开始</li>
<li>truncate没有返回值，delete有返回值（剩余的行数）</li>
<li>truncate删除不能回滚，delete可以回滚</li>
</ul>
<p>DDL数据定义语言：对库和表的创建、修改、删除</p>
<p>库的创建：create database 【if not exist】库名</p>
<p>更改库的字符集： alter database 库名 character set 字符集名</p>
<p>库的删除： drop database 【if exist】库名</p>
<p>表的创建：create table 【if not exist】表名（列名 列的类型【长度约束】）</p>
<p>修改列名：alter table 表名 change column 原列名 新列名 列的类型</p>
<p>修改列的类型或约束：alter table 表名 modify column 列名 新类型或约束</p>
<p>添加新列：alter table 表名 add column 列名 列的类型</p>
<p>删除列：alter table 表名 drop column 列名</p>
<p>修改表名：alter table 表名 rename to 新表名</p>
<p>表的删除：drop table 【if exist】表名</p>
<p>仅仅复制表的结构：create table 新表名 like 旧表名</p>
<p>复制表的结构和数据：create table 新表名 select * from 旧表名</p>
<p>只复制表的部分数据：create table 新表名  select A ，B from 旧表名 where 筛选条件</p>
<p>常见的数据类型：整形</p>
<p>整形：</p>
<ul>
<li>每种都有无符号和有符号两种类型</li>
<li>如果不设置无符号还是有符号，默认为有符号</li>
<li>设置无符号需要追加unsigned</li>
<li>若插入数值超出范围，则报out of range警告，且设置为临界值</li>
<li>如果不设置显示长度，会有默认的长度，zerofill零填充，如int（7） zerofill unsigned，且使用zerofill直接自动转成无符号数</li>
</ul>
<p>小数：float/double（浮）decimal/dec（定）</p>
<ul>
<li>M：整数部分+小数部分</li>
<li>D：小数部分</li>
<li>如果超出范围，则插入临界值</li>
<li>M和D都可以省略，如果是decimal，则默认M=10，D=0；如果是float和double，则根据插入数值的精度来决定精度</li>
<li>定点性精确度较高</li>
</ul>
<h1 id="P8"><a href="#P8" class="headerlink" title="P8"></a>P8</h1><p>字符型：</p>
<ul>
<li>char固定长度字符，varchar可变长度字符</li>
<li>char（M）M最大的字符数，可省略，默认为1，比较耗费空间，效率高</li>
<li>varchar（M）M不可以省略，节省空间，效率低</li>
<li>enum枚举类型</li>
<li>set集合类型，可同时插入多个值</li>
</ul>
<p>日期型：</p>
<ul>
<li>date：日期</li>
<li>time：时间</li>
<li>year：年</li>
<li>timestamp：时间戳，日期+时间，4字节，范围小，受时区影响</li>
<li>datetime：日期+时间，8字节，范围大，不受时区影响</li>
</ul>
<p>约束：</p>
<ul>
<li>not null：非空，用于保证字段的值不能为空</li>
<li>default：默认，用于保证字段有默认值</li>
<li>primary key：主键，用于保证字段的值具有唯一性，并且为空</li>
<li>unique：唯一，用于保证该字段的值具有唯一性，可以为空</li>
<li>check：检查约束</li>
<li>foreign key：外键，用于限制两个表的关系，用于保证该字段的值必须来自与主表的关联列的值</li>
</ul>
<p>添加约束的时机：创建表时，修改表时</p>
<p>约束的添加分类：</p>
<ul>
<li>列级约束：六大约束语法上都支持，但是外键约束没有效果，不可以起约束名</li>
<li>表级约束：除了非空、默认，其他的都支持，在各个字段的最下面，constraint 约束名 约束类型（列名），主键起约束名没有效果</li>
</ul>
<p>主键 VS 唯一：</p>
<ul>
<li>主键与唯一都保证唯一性</li>
<li>主键不能为空，唯一可以为空</li>
<li>主键最多有一个，唯一可以有多个 </li>
<li>都允许组合，但不推荐</li>
</ul>
<p>外键：</p>
<ul>
<li>要求在从表设置外键关系</li>
<li>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</li>
<li>主表的关联列必须是一个key（一般是主键或唯一）</li>
<li>插入数据时，先插入主表，再删除从表</li>
<li>删除数据时，先删除从表，再删除主表</li>
</ul>
<p>修改表时添加约束：</p>
<ul>
<li>添加列级约束：alter  table 表名 modify column 字段名 字段类型 新约束</li>
<li>添加表级约束：alter table 表名 add 【constraint 约束名】约束类型（字段名）</li>
</ul>
<p>修改表时删除约束：</p>
<ul>
<li>alter table 表名 modify column 列名 约束 null（删除非空）/int（删除默认）</li>
<li>alter table 表名 drop 约束 列名</li>
</ul>
<p>标识列：自增长列</p>
<ul>
<li>创建表时设置标识列：在约束后加auto_increment</li>
<li>标识列必须与键搭配</li>
<li>一个表只能有一个标识列</li>
<li>标识列的类型只能是数值型</li>
<li>标识列可以通过set auto_increment_increment=a修改步长，可以通过手动插入设置初值</li>
</ul>
<p>修改表时设置标识列：在约束后加auto_increment</p>
<p>修改表时删除标识列：设置时把auto_increment去掉</p>
<p>TCL：事务控制语言</p>
<p>事务：一个不可分割的整体，单元中语句错误会回滚</p>
<ul>
<li>原子性：事务不可分割</li>
<li>一致性：数据库从一个一致状态转换到另一个一致状态</li>
<li>隔离性：各个事务不能互相干扰</li>
<li>持久性：事务一旦提交，会永久改变数据</li>
</ul>
<p>显式事务：具有明显的开启和结束的标记</p>
<p>前提：必须先设置自动提交功能禁用</p>
<p>步骤：</p>
<ul>
<li>开启事务，set autocommit=0，start transaction（可选）</li>
<li>编写sql语句（增删改查）</li>
<li>结束事务： commit；提交事务 rollback；回滚事务</li>
</ul>
<p>事务的隔离级别：</p>
<ul>
<li>read uncommitted：出现脏读、幻读、不可重复读</li>
<li>read committed：防止脏读</li>
<li>repeatable read：防止脏读和不可重复读</li>
<li>serializable：全部防止</li>
<li>MySQL中默认repeatable</li>
</ul>
<p>savepoint：设置保存点</p>
<p>rollback：回滚到保留点</p>
<h1 id="P9"><a href="#P9" class="headerlink" title="P9"></a>P9</h1><p>创建视图：create view 视图名 as 查询语句</p>
<p>视图的好处：</p>
<ul>
<li>重用sql语句</li>
<li>简化操作，不必知道查询细节</li>
<li>保护数据，提高安全性</li>
</ul>
<p>视图的修改：</p>
<ul>
<li>方式一：create or replace view 视图名 as 查询语句</li>
<li>方式二：alter view 视图名 as 查询语句</li>
</ul>
<p>视图的删除：</p>
<ul>
<li>drop view 视图名，视图名，……</li>
</ul>
<p>查看视图：</p>
<ul>
<li>desc 视图名</li>
<li>show create view 视图名</li>
</ul>
<p>视图的更新：（很少用）</p>
<ul>
<li>插入：insert into 视图名 values（值）</li>
<li>修改：update 视图名 set 列名=值</li>
<li>删除：delete from 视图名</li>
</ul>
<p>具备以下特点的sql语句，不允许更新视图：</p>
<ul>
<li>包含分组函数、distinct、group by、having、union</li>
<li>常量视图</li>
<li>select包含子查询</li>
<li>join</li>
<li>from一个不能更新的视图</li>
<li>where子句的子查询引用了from子句中的表</li>
</ul>
<p>视图 VS 表：</p>
<ul>
<li>视图只存储了逻辑</li>
<li>表存储了数据</li>
</ul>
<p>delete VS truncate：</p>
<ul>
<li>delete能回滚</li>
<li>truncate不能回滚</li>
</ul>
<p>级联删除：添加外键时追加on delete cascade</p>
<p>级联置空：添加外键时追加on delete set null</p>
<p>系统变量：</p>
<ul>
<li>查看所有的系统变量：show global|【session】 variables</li>
<li>查看部分：show global|【session】 variables like ‘%char%’</li>
<li>查看指定：select @@global|【session】系统变量名</li>
<li>set global|【session】 系统变量名=值</li>
<li>set @@global|【session】.系统变量名=值</li>
<li>global全局、session会话，默认session</li>
</ul>
<p>用户变量：作用域为当前会话</p>
<ul>
<li>声明并初始化：set @用户变量名=值</li>
<li>声明并初始化：set @用户变量名：=值</li>
<li>声明并初始化：select @用户变量名：=值</li>
<li>赋值：set @用户变量名=值</li>
<li>赋值：set @用户变量名：=值</li>
<li>赋值：select @用户变量名：=值</li>
<li>赋值：select 字段 into 变量名 from 表</li>
<li>使用：select @用户变量名</li>
</ul>
<p>局部变量：仅仅定义在begin和end中有效，只能定义在begin end中的第一句话</p>
<ul>
<li>声明：declare 变量名 类型</li>
<li>声明：declare变量名 类型 default 值</li>
<li>赋值：set 局部变量名=值</li>
<li>赋值：set 局部变量名：=值</li>
<li>赋值：select @局部变量名：=值</li>
<li>赋值：select 字段 into 变量名 from 表</li>
<li>使用：select 局部变量名</li>
</ul>
<p>创建语法：</p>
<ul>
<li>create procedure 存储过程名（参数列表）begin ……end</li>
<li>参数列表包含三部分，参数模式、参数名、参数类型</li>
<li>参数IN：输入参数；参数OUT：输出参数；参数INOUT：都可以</li>
<li>如果存储过程体只有一句话，则begin end可以省略</li>
<li>存储过程体的每条sql语句结尾必须加分号</li>
<li>delimiter 结束标记</li>
</ul>
<h1 id="P10"><a href="#P10" class="headerlink" title="P10"></a>P10</h1><p>调用语法：</p>
<ul>
<li>call 存储过程名（实参列表）；</li>
</ul>
<p>删除存储过程：</p>
<ul>
<li>语法：drop procedure 存储过程名</li>
</ul>
<p>查看存储过程的信息：</p>
<ul>
<li>语法：show create procedure 存储过程名</li>
</ul>
<h1 id="P11"><a href="#P11" class="headerlink" title="P11"></a>P11</h1><p>创建函数：</p>
<ul>
<li>create function 函数名（参数列表）returns 返回类型 begin 函数体 end</li>
<li>参数列表：参数名、参数类型</li>
</ul>
<p>调用函数：</p>
<ul>
<li>select 函数名（函数列表）</li>
</ul>
<p>查看函数：</p>
<ul>
<li>show create function 函数名</li>
</ul>
<p>删除函数：</p>
<ul>
<li>drop function 函数名</li>
</ul>
<p>流程控制结构：</p>
<ul>
<li>顺序结构：程序从下往下依次执行</li>
<li>分支结构：程序从两条或多条路径中选择一条执行</li>
<li>循环结构：程序在满足一定条件的情况下，重复执行一段代码</li>
</ul>
<p>分支结构：</p>
<ul>
<li>if函数：if （表达式1，表达式2，表达式3） 如果表达式1成立，则返回2，否则返回3</li>
<li>case等值判断结构：case 变量|表达式|字段 when 要判断的值 then返回的值 end</li>
<li>case区间判断结构：case 变量|表达式|字段 when 要判断的条件 then返回的值 end</li>
<li>if多重分支结构：if 条件1 then 语句1；elseif 条件2 then 语句2…… else 语句n；end if；  应用在begin end中</li>
</ul>
<p>循环结构：</p>
<ul>
<li>iterate相当于continue</li>
<li>leave相当于break</li>
<li>【标签】while 循环条件 do 循环体； end while【标签】</li>
<li>【标签】loop 循环体；end loop 【标签】</li>
<li>【标签】repeat 循环体；until 结束循环的条件 end repeat【标签】</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/25/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" data-id="ckd18a4b30000jcv23swa1a19" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络复习提纲" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/" class="article-date">
  <time datetime="2020-07-21T14:54:36.185Z" itemprop="datePublished">2020-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/">计算机网络复习提纲</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1.计算机网络概述"></a>1.计算机网络概述</h1><h2 id="1-1计算机网络的概念"><a href="#1-1计算机网络的概念" class="headerlink" title="1.1计算机网络的概念"></a>1.1计算机网络的概念</h2><p>计算机网络是一个将分散的具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统，互联且自治。</p>
<p>计算机网络的功能：数据通信、资源共享、分布式管理、提高可靠性、负载均衡</p>
<p>计算机网络的组成：硬件、软件、协议</p>
<p>工作方式：边缘部分（C/S与P2P）、核心部分</p>
<p>功能组成：资源子网、通信子网</p>
<p>分类：</p>
<ul>
<li>分布范围：广域网、城域网、局域网、个人区域网</li>
<li>使用者：共用网、专用网</li>
<li>交换技术：电路交换、报文交换、分组交换</li>
<li>拓扑结构：总线型、星型、环形、网状型</li>
<li>传输技术：广播式、点对点</li>
</ul>
<h2 id="1-2性能指标"><a href="#1-2性能指标" class="headerlink" title="1.2性能指标"></a>1.2性能指标</h2><p>比特率：数据传输速度</p>
<p>带宽：某网络的最高数据率</p>
<p>吞吐量：单位时间通过每个网络的数据量</p>
<p>延时：数据从网络一端传送到另一端所需的时间</p>
<p>时延带宽积：传播时延$\times$ 带宽，即某段链路现在有多少比特</p>
<p>往返时延RTT：发送方发送数据开始，到发送方收到接收方的确认的时间</p>
<p>信道利用率：有数据通过的时间/总时间</p>
<p>网络利用率：信道利用率加权平均值</p>
<h2 id="1-3OSI模型"><a href="#1-3OSI模型" class="headerlink" title="1.3OSI模型"></a>1.3OSI模型</h2><p>分为七层：</p>
<ul>
<li>应用层：和用户交互产生网络流量的程序</li>
<li>表示层：数据格式变换、数据加密解密、数据压缩和恢复</li>
<li>会话层：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据</li>
<li>传输层：进程的通信，可靠传输/不可靠传输，差错控制、流量控制、复用分用</li>
<li>网络层：传递数据报，路由选择、流量控制、差错控制、拥塞控制</li>
<li>数据链路层：传送帧，成帧、差错控制、流量控制、控制对信道的访问</li>
<li>物理层：传输比特，定义接口特性、定义传输模式、定义传输速率、比特同步、比特编码</li>
</ul>
<h2 id="1-4TCP-IP"><a href="#1-4TCP-IP" class="headerlink" title="1.4TCP/IP"></a>1.4TCP/IP</h2><p>TCP/IP协议栈：应用层、传输层、网际层、网络接口层</p>
<p>OSI与TCP/IP的共同点：都分层、基于独立的协议栈、可以实现异构网络互连</p>
<p>OSI与TCP/IP的不同点：OSI的网络层是无连接+面向连接，TCP/IP的网络层是无连接；OSI的传输层是面向连接的，TCP/IP的传输层是无连接+面向连接的</p>
<p>5层参考模型：</p>
<ul>
<li>应用层：支持各种网络应用</li>
<li>传输层：进程之间的数据传输</li>
<li>网络层：源主机到目的主机的数据分组路由与转发</li>
<li>数据链路层：把网络层传下来的数据报组装成帧</li>
<li>物理层：比特传输</li>
</ul>
<p>越底层，封装的越多，传递过程中先封装再解封装</p>
<h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h1><h2 id="2-1物理层概念"><a href="#2-1物理层概念" class="headerlink" title="2.1物理层概念"></a>2.1物理层概念</h2><p>物理层解决如何在传输媒体上传输比特流，主要任务是确定与传输媒体接口有关的一些特性，即定义标准</p>
<ul>
<li>机械特性：规定规格、接口形状、引线数目、引脚数量和排列情况</li>
<li>电气特性：线路上信号的电压范围、阻抗匹配、传输速率和距离限制</li>
<li>功能特性：指明电平意义、接口部件信号线的用途</li>
<li>规程特性：各条线路的工作规程与时序的关系</li>
</ul>
<h2 id="2-2数据通信基础知识"><a href="#2-2数据通信基础知识" class="headerlink" title="2.2数据通信基础知识"></a>2.2数据通信基础知识</h2><p>单工通信：只有一个方向的通信，只需要一条信道</p>
<p>半双工通信：双方都可以发送或接收信息，但不能同时发送，需要两条信道</p>
<p>全双工通信：双方可以同时发送或接收信息，需要两条信道（注意物理与逻辑信道的区别）</p>
<p>串行传输：速度慢、费用低、适合远距离传输</p>
<p>并行传输：速度快、费用高、适合近距离传输</p>
<p>码元：一个固定时长的信号波形，是数字信号的计量单位，时长称为码元宽度，一个码元可携带多个比特的信息量</p>
<p>速率：数据的传输速率，可用码元传输速率和信息传输速率来表示</p>
<p>码元传输速率：单位时间内传递的码元个数，单位波特</p>
<p>信息传输速率：单位时间内传递的比特数</p>
<p>带宽：最高数据率，单位b/s</p>
<h2 id="2-3奈氏准则和香农定理"><a href="#2-3奈氏准则和香农定理" class="headerlink" title="2.3奈氏准则和香农定理"></a>2.3奈氏准则和香农定理</h2><p>影响失真程度的因素：码间传输速率、信号传输距离、噪声干扰、传输媒体质量</p>
<p>信道带宽：信道能通过的最高频率与最低频率之差</p>
<p>码间串扰：接收端收到的信号波形失去了码元之间清晰界限的现象</p>
<p>奈氏准则：在理想低通条件下，为避免码间串扰，极限码元传输速率为2W波特，W是信道带宽，单位Hz</p>
<p>极限数据率为：2Wlog<del>2</del>V，V为码元离散电平数目</p>
<p>信噪比（dB）=10log<del>10</del>(S/N)</p>
<p>数据传输速率上限：Wlog<del>2</del>(1+S/N)</p>
<h2 id="2-4编码与调制"><a href="#2-4编码与调制" class="headerlink" title="2.4编码与调制"></a>2.4编码与调制</h2><p>基带信号：直接表达了要传输的信息的信号，适用于近距离</p>
<p>宽带信号：调制后的在模拟信道上传输的信号，适用于长距离</p>
<ul>
<li>数字数据到数字信号：数字发送器，非归零编码、曼彻斯特编码、差分曼彻斯特编码、归零编码、反向不归零编码、4B/5B编码</li>
</ul>
<p>数字数据到模拟信号：调制器，调幅、调频、调相</p>
<p>模拟数据到数字信号：PCM编码器，抽样、量化、编码</p>
<p>模拟数据到模拟信号：放大器调制器</p>
<h2 id="2-5物理层传输介质"><a href="#2-5物理层传输介质" class="headerlink" title="2.5物理层传输介质"></a>2.5物理层传输介质</h2><p>双绞线：两根并排绞合互相绝缘的铜导线，加金属屏蔽层的为屏蔽双绞线。价格较为便宜</p>
<p>同轴电缆：导体铜制芯线、绝缘层、网状编织屏蔽层和塑料外层构成，50Ω为基带用，75Ω为宽带用。抗干扰性较好，传输距离更远，价格更贵</p>
<p>光纤：利用光导纤维传递光脉冲进行通信，带宽很大，由纤芯和包层构成，单模光纤衰耗小，多模光纤易失真</p>
<p>非导向性传输介质：通信容量大、距离远、覆盖广、传播时延长、误码率高，如无线电波、微波、红外线、激光</p>
<h2 id="2-6物理层设备"><a href="#2-6物理层设备" class="headerlink" title="2.6物理层设备"></a>2.6物理层设备</h2><p>中继器的功能：对信号进行再生和还原，延长网络的长度</p>
<p>中继器的两端是网段，且两端速率需要相同，两端必须是同一个协议，遵循5-4-3规则</p>
<p>集线器：对信号进行再生放大转发，对衰减的信号再次进行放大，接着转发到其他所有处于工作状态的端口上，增加信号传输的距离，不具备定向传送能力，不能分割冲突域，各工作主机平分带宽</p>
<h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3.数据链路层"></a>3.数据链路层</h1><h2 id="3-1数据链路层的基本概念"><a href="#3-1数据链路层的基本概念" class="headerlink" title="3.1数据链路层的基本概念"></a>3.1数据链路层的基本概念</h2><p>结点：路由器、主机</p>
<p>链路：网络中两个结点之间的物理通道</p>
<p>数据链路：网络中两个结点之间的逻辑通道</p>
<p>帧：数据链路层的协议数据单元，封装网络层数据报</p>
<p>数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报，将连接改造为逻辑上无差错的数据链路</p>
<p>功能概述：</p>
<ul>
<li>为网络层提供服务，无确认无连接服务、有确认无连接服务、有确认面向连接服务</li>
<li>链路管理：连接的建立、维持、释放</li>
<li>组帧</li>
<li>流量控制</li>
<li>差错控制</li>
</ul>
<h2 id="3-2封装成帧和透明传输"><a href="#3-2封装成帧和透明传输" class="headerlink" title="3.2封装成帧和透明传输"></a>3.2封装成帧和透明传输</h2><p>封装成帧：在一段数据的前后部分添加首部和尾部</p>
<p>组帧的四种方法：字符计数法、字符填充法、零比特填充法、违规编码法</p>
<p>保证透明传输，即不能因为组帧策略而导致传输出错</p>
<p>由于字节计数脆弱，字符填充复杂，所以普遍采取零比特填充和违规编码</p>
<h2 id="3-3差错控制"><a href="#3-3差错控制" class="headerlink" title="3.3差错控制"></a>3.3差错控制</h2><p>奇偶校验、CRC、海明码</p>
<h2 id="3-4流量控制与可靠传输机制"><a href="#3-4流量控制与可靠传输机制" class="headerlink" title="3.4流量控制与可靠传输机制"></a>3.4流量控制与可靠传输机制</h2><p>较高的发送速度与较低的接受能力不匹配，需要流量控制，数据链路层的这种控制是点到点的，方式是接收方收不下就不回复确认</p>
<p>停止等待协议：</p>
<ul>
<li>设置超时计时器，每次发动时启动，超时计时器设置的重传时间应当比RTT长一些</li>
<li>发送一个帧后，必须保留副本</li>
<li>数据帧与确认帧必须编号</li>
<li>若ACK丢失，会自动重发，接收方丢弃重复的帧并重传确认帧</li>
<li>若ACK迟到，则发送方忽略重复的确认帧</li>
<li>信道利用率为发送数据的时间/整个周期</li>
</ul>
<p>后退N帧协议：</p>
<ul>
<li>累计确认</li>
<li>接收方只按顺序接收帧，不按序则丢弃</li>
<li>确认序列号最大的、按序到达的帧</li>
<li>发送窗口最大为2^n^-1</li>
<li>提高了信道利用率，降低了传送效率</li>
</ul>
<p>选择重传协议：</p>
<ul>
<li>对数据帧逐一确认，收一个确认一个</li>
<li>只重传出错帧</li>
<li>接收方有缓存</li>
<li>最大窗口W<del>Tmax</del>=W<del>Rmax</del>=2^n-1^</li>
</ul>
<h2 id="3-5介质访问控制"><a href="#3-5介质访问控制" class="headerlink" title="3.5介质访问控制"></a>3.5介质访问控制</h2><p>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开</p>
<ul>
<li>频分复用</li>
<li>时分复用</li>
<li>统计时分复用</li>
<li>波分复用</li>
<li>码分复用：利用正交</li>
</ul>
<ul>
<li>轮询：主节点轮流邀请从属节点发送数据</li>
<li>令牌传递协议：每个节点都可在持有令牌时发送数据，并不是无限制地持有令牌，常用于负载较重、通信量较大的网络中</li>
</ul>
<ul>
<li>ALOHA想发就发，时隙ALOHA在时间片段开始时才能发</li>
<li>ALOHA比时隙ALOHA吞吐量低，效率更低</li>
</ul>
<ul>
<li>1-坚持CSMA，空闲则直接传输，忙则一直监听，到空闲马上传输</li>
<li>非坚持CSMA，忙则等待一个随机的时间之后在进行监听</li>
<li>p-坚持CSMA，空闲则以p概率直接传输，1-p概率到下一个时间槽再传输</li>
</ul>
<ul>
<li>CSMA/CD的基本退避时间为往返传播时延</li>
<li>截断二进制指数规避算法：定义重传次数k，但k不超过10，从[0,1,…,2^k^-1]中随机选取一个数r，重传所需退避时间为r倍的基本退避时间，重传16次不成功，则向高层报错</li>
<li>最小帧长：往返传播时延$\times$数据传输速率，以太网规定为64B</li>
</ul>
<ul>
<li>CSMA/CA：发送前先检测信道是否空闲，空闲则发出RTS，接收端收到RTS后，响应CTS，发送端接收到CTS，开始发送数据帧，同时预约信道。接收端收到数据帧后，用CRC检测数据是否正确，正确则响应ACK帧</li>
<li>发送方收到ACK后，就可以进行下一个数据帧的发送，若没有则采用二进制退避算法确定推出时间并重发</li>
<li>CSMA/CD与CSMA/CA的相同点：先听再说</li>
<li>CSMA/CD与CSMA/CA的不同点：传输介质不同，前者以太网（有线），后者无线局域网（无线）；载波检测方式不同，前者通过电压，后者通过能量和载波检测；前者检测冲突，后者避免冲突</li>
</ul>
<h2 id="3-6局域网"><a href="#3-6局域网" class="headerlink" title="3.6局域网"></a>3.6局域网</h2><p>局域网特点：</p>
<ul>
<li>覆盖的地理范围较小</li>
<li>使用专门铺设的传输介质，数据传输速率高</li>
<li>可靠性高</li>
<li>各站为平等关系，共享传输信道</li>
<li>采用分布式控制和广播式通信，能进行广播或组播</li>
</ul>
<p>局域网拓扑结构：星型、总线型、环形、树形</p>
<p>局域网传输介质：</p>
<ul>
<li>有线局域网：双绞线、同轴电缆、光纤</li>
<li>无线局域网：电磁波</li>
</ul>
<p>局域网介质访问方法：</p>
<ul>
<li>CSMA/CD：常用于总线型局域网、树形网络</li>
<li>令牌总线：总线型、树形</li>
<li>令牌环：环形</li>
</ul>
<p>局域网分类：以太网、令牌环网、FDDI网、ATM网、无线局域网</p>
<p>IEEE802.3——以太网</p>
<p>IEEE802.5——令牌环网</p>
<p>IEEE802.8——光纤</p>
<p>IEEE802.11——无线局域网</p>
<p>链路层的两个子层：</p>
<ul>
<li>逻辑链路层LLC负责识别网络层协议，对其进行封装，为网络层提供服务</li>
<li>介质访问控制层MAC主要负责数据帧的封装/卸装，帧的寻址和识别，帧的接收和发送，链路的管理，帧的差错控制</li>
</ul>
<p>以太网：基带总线局域网规范，使用CSMA/CD</p>
<ul>
<li>造价低廉</li>
<li>应用最广</li>
<li>结构简单</li>
<li>网络速率：10Mb/s~10Gb/s</li>
<li>无连接：无握手过程</li>
<li>不可靠：只实现无差错接收，不实现可靠传输</li>
<li>以太网现在的拓扑：逻辑上总线型、物理上星型</li>
<li>以太网现在的传输介质：双绞线+集线器</li>
<li>100Base-T以太网传输速率10Mb/s，采用曼彻斯特编码</li>
<li>ROM上有MAC地址，48位二进制</li>
<li>以太网MAC帧 ：前导码8+目的地址6+原地址6+类型2+数据（46~1500）+FCS4</li>
<li>吉比特以太网，支持全双工与半双工</li>
<li>10吉比特只支持全双工</li>
</ul>
<p>无线局域网：</p>
<ul>
<li>MAC帧头：帧控制2+生存周期2+接收端6+发送端6+目的地址6+序列控制2+源地址4</li>
<li>分类：有固定基础设施无线局域网；无固定基础设施无线局域网的自组织网络</li>
</ul>
<h2 id="3-7PPP协议和HDLC协议"><a href="#3-7PPP协议和HDLC协议" class="headerlink" title="3.7PPP协议和HDLC协议"></a>3.7PPP协议和HDLC协议</h2><p>广域网：通信子网使用分组交换技术</p>
<p>PPP点对点协议：只支持全双工链路</p>
<p>PPP协议的帧格式首部、信息部分、尾部，前后有帧定界符</p>
<p>HDLC协议：高级数据链路控制，面向比特，采用全双工通信，采用CRC检验，有编号和确认机制，可靠传输</p>
<p>HDLC帧格式：没有2B协议字段</p>
<h2 id="3-8链路层设备"><a href="#3-8链路层设备" class="headerlink" title="3.8链路层设备"></a>3.8链路层设备</h2><p>网桥：根据MAC帧目的地址对帧进行转发和过滤，可互联不同物理层、不同MAC子层和不同速率的以太网</p>
<p>透明网桥：站点不知道发送的帧将经过哪些网桥</p>
<p>源路由网桥：发送帧时将详细路由信息放在帧的首部</p>
<p>以太网交换机：</p>
<ul>
<li>直通式交换机：查完目的地址直接转发，延迟小，可靠性低，不能完成不同速率端口的转换</li>
<li>存储转发式交换机：将帧放入高速缓存，并检查是否正确，延迟大，可以支持具有不同速率端口的转换</li>
</ul>
<p>冲突域：在一个冲突域下的节点都能收到被发送的所有的帧，同一时间只能有一台设备发送信息</p>
<p>广播域：网络中能接受任一设备发出的广播帧的所有设备的集合</p>
<p>物理层设备（中继器、集线器）不能隔离冲突域，不能隔离广播域</p>
<p>链路层设备（网桥、交换机）能隔离冲突域，不能隔离广播域</p>
<p>网络层设备（路由器）能隔离冲突域，能隔离广播域</p>
<h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h1><h2 id="4-1网络层概述"><a href="#4-1网络层概述" class="headerlink" title="4.1网络层概述"></a>4.1网络层概述</h2><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，传输单位是数据报</p>
<p>网络层功能：路由选择和分组转发、异构网络互连、拥塞控制</p>
<p>电路交换：</p>
<ul>
<li>建立连接——通信——释放连接</li>
<li>优点：通信时延小，有序传输，没有冲突，实时性强</li>
<li>缺点：建立连接时间长，线路独占，使用效率低，灵活性差，无差错控制能力</li>
</ul>
<p>报文交换：</p>
<ul>
<li>优点：无需建立连接，存储转发，动态分配线路，可靠性高，线路利用率高，多目标服务</li>
<li>缺点：有存储转发时延，报文大小不固定，网络节点需要有较大缓存空间</li>
</ul>
<p>分组交换：</p>
<ul>
<li>优点：相较于报文交换，存储管理更加容易</li>
<li>缺点：需要传输额外信息量，需要重新排序</li>
</ul>
<p>数据报：无连接服务，每个分组携带源和目的地址</p>
<p>虚电路：连接服务，建立虚路径，各节点需要维持虚电路表，能保证有序到达</p>
<h2 id="4-2IP协议"><a href="#4-2IP协议" class="headerlink" title="4.2IP协议"></a>4.2IP协议</h2><p>IP数据报格式：</p>
<ul>
<li>版本：IPV4和IPV6</li>
<li>首部长度：单位是4B，最小是5</li>
<li>区分服务：指示期望获得哪种类型的服务</li>
<li>总长度：首部+数据，单位是B</li>
<li>生存时间：IP分组的保质期，经过一个路由器就-1</li>
<li>协议：数据部分的协议</li>
<li>首部检验和：只检验首部</li>
<li>源IP地址和目的IP地址：32位</li>
<li>可选字段：0~40B，用来支持排错、测量以及安全等措施</li>
<li>填充：全0，把首部补成4B的整数倍</li>
<li>标识：同一数据报的分片使用统一标识</li>
<li>标志：只有两位有意义，中间位DF=1禁止分片，DF=0允许分片，最低位MF=1后面还有分片，MF=0代表最后一片</li>
<li>片偏移：指较长分组分片后，某片在原分组中的相对位置，以8B为单位</li>
</ul>
<p>最大传送单元MTU是链路层数据帧可封装数据的上限</p>
<p>以太网的MTU是1500字节</p>
<p>IP地址：全世界唯一的32位标识符，标识路由器主机的接口</p>
<p>分类IP地址：</p>
<ul>
<li>A类：0+网络号7+主机号</li>
<li>B类：10+网络号14+主机号</li>
<li>C类：110+网络号21+主机号</li>
<li>D类：1110+多播地址</li>
<li>E类：1111+保留为今后使用</li>
</ul>
<p>特殊IP地址：</p>
<table>
<thead>
<tr>
<th>网络号</th>
<th>主机号</th>
<th>作为源地址</th>
<th>作为目的地址</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>全0</td>
<td>全0</td>
<td>可以</td>
<td>不可以</td>
<td>本网范围内表示整个主机</td>
</tr>
<tr>
<td>全0</td>
<td>特定值</td>
<td>不可以</td>
<td>可以</td>
<td>表示本网内某个特定主机</td>
</tr>
<tr>
<td>全1</td>
<td>全1</td>
<td>不可以</td>
<td>可以</td>
<td>本网广播地址</td>
</tr>
<tr>
<td></td>
<td>全1</td>
<td>不可以</td>
<td>不可以</td>
<td>网络地址</td>
</tr>
<tr>
<td>特定值</td>
<td>全1</td>
<td>不可以</td>
<td>可以</td>
<td>直接广播地址，对特定网络上的所有主机进行广播</td>
</tr>
<tr>
<td>127</td>
<td>任何数（非全0/1)</td>
<td>可以</td>
<td>可以</td>
<td>用于本地软件环回测试，称作环回地址</td>
</tr>
</tbody></table>
<p>私有IP地址：内部网络用</p>
<ul>
<li>A类：10.0.0.0~10.255.255.255</li>
<li>B类：172.16.0.0~172.31.255.255</li>
<li>C类：192.168.0.0~192.168.255.255</li>
</ul>
<p>网络地址转换NAT：在专用网连接到因特网的路由器上安装NAT软件，至少有一个有效的外部全球地址</p>
<p>子网掩码：网络号与子网号全1，与主机的IP地址按位相与得到网络地址</p>
<p>CIDR记法：IP地址后加上/，然后写上网络前缀的位数</p>
<p>ARP协议：完成主机或路由器IP地址到MAC地址的映射</p>
<p>ARP使用过程：检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求，目的地址收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存</p>
<p>DHCP协议：动态主机配置协议，使用C/S方式，通过广播方式进行交互，基于UDP，主机从服务器动态获得IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许地址重用，支持移动用户加入网络</p>
<p>ICMP差错报文：</p>
<ul>
<li>终点不可达</li>
<li>源点抑制</li>
<li>时间超过</li>
<li>参数问题</li>
<li>改变路由</li>
</ul>
<p>ICMP询问报文：</p>
<ul>
<li>回送请求和回答报文</li>
<li>时间戳请求和回答报文</li>
</ul>
<h2 id="4-3IPV6"><a href="#4-3IPV6" class="headerlink" title="4.3IPV6"></a>4.3IPV6</h2><p>IPV6和IPV4的不同：</p>
<ul>
<li>IPV6地址从32位扩大到128位</li>
<li>IPV6将IPV4的校验和字段彻底移除，以减少每跳的处理时间</li>
<li>IPV6将可选字段移除首部，路由器不对扩展首部进行检查，提高了效率</li>
<li>IPV6支持即插即用</li>
<li>IPV6首部长度是8B的整数倍</li>
<li>IPV6只能在主机处分片</li>
</ul>
<p>IPV6地址可以压缩</p>
<p>IPV6向IPV4过渡方法：双协议栈、隧道技术</p>
<h2 id="4-4路由算法"><a href="#4-4路由算法" class="headerlink" title="4.4路由算法"></a>4.4路由算法</h2><p>自治系统AS：使用内部网关协议</p>
<p>RIP协议：</p>
<ul>
<li>分布式基于向量的路由选择协议，是因特网的协议标准，优点是简单，每个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录，16表示网络不可达，只适用于小型互联网</li>
<li>仅和相邻路由器交换信息，交换自己的路由表，每30秒交换一次路由信息，然后根据新信息更新路由表，若超过180s未收到相邻的通告，则判定邻居没了</li>
<li>RIP协议好消息传得快，坏消息传的慢</li>
<li>应用层协议，使用UDP传送数据</li>
</ul>
<p>OSPF：开放最短路径优先协议</p>
<ul>
<li>使用最短路径算法</li>
<li>收敛很快</li>
<li>适合大规模网络</li>
<li>用IP数据报传送</li>
</ul>
<p>BGP：</p>
<ul>
<li>外部网关协议</li>
<li>应用层协议，TCP传送，支持CIDR，只在发生变化时更新有变化的部分</li>
</ul>
<h2 id="4-5IP组播"><a href="#4-5IP组播" class="headerlink" title="4.5IP组播"></a>4.5IP组播</h2><p>组播地址范围为：224.0.0.0~239.255.255.255（D类），只能用作分组的目的地址</p>
<ul>
<li>组播数据报不提供可靠交符，用UDP</li>
<li>不产生ICMP差错报文</li>
</ul>
<p>硬件组播：前面以01-00-5E打头，余下的6个十六进制根据IP组播组地址的最后23位转换得到</p>
<p>IGMP：主机想加入组播时，向组播组的组播地址发送一个IGMP报文，声明自己要成为该组的成员，本地的组播路由器收到IGMP报文后，要传给其他组播路由器；本地组播路由器周期性探寻主机是否还是组播成员，只要有一个活跃，则认为该组活跃。</p>
<h2 id="4-6移动IP"><a href="#4-6移动IP" class="headerlink" title="4.6移动IP"></a>4.6移动IP</h2><p>本地代理有需要时转给外部代理</p>
<h2 id="4-7网络层设备"><a href="#4-7网络层设备" class="headerlink" title="4.7网络层设备"></a>4.7网络层设备</h2><p>路由器根据路由选择协议构造出路由表，定期维护，根据转发表对分组进行转发</p>
<p>路由器中的输入或输出队列产生溢出是分组丢失的重要原因</p>
<h1 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5.传输层"></a>5.传输层</h1><h2 id="5-1传输层概述"><a href="#5-1传输层概述" class="headerlink" title="5.1传输层概述"></a>5.1传输层概述</h2><p>功能：</p>
<ul>
<li>进程与进程之间的逻辑通信</li>
<li>复用和分用</li>
<li>差错检测</li>
</ul>
<p>端口号：16bit</p>
<p>套接字：主机IP地址+端口号</p>
<h2 id="5-2UDP"><a href="#5-2UDP" class="headerlink" title="5.2UDP"></a>5.2UDP</h2><p>主要特点：</p>
<ul>
<li>无连接，减少时延</li>
<li>不保证可靠交付</li>
<li>面向报文，适合一次传少量数据的网络应用</li>
<li>无拥塞控制，适合实时应用</li>
<li>首部开销小，8B</li>
</ul>
<p>首部格式：源端口号+目的端口号+UDP长度+UDP检验和</p>
<h2 id="5-3TCP"><a href="#5-3TCP" class="headerlink" title="5.3TCP"></a>5.3TCP</h2><p>TCP协议特点：</p>
<ul>
<li>面向连接的传输层协议</li>
<li>点对点</li>
<li>可靠交付、可靠有序、不丢不重</li>
<li>全双工</li>
<li>面向字节流</li>
</ul>
<p>TCP报文段结构：</p>
<ul>
<li>序号：报文段发送数据的第一个字节的序号</li>
<li>确认号：期望收到对方下一个报文段的第一个数据字节的序号，若确认号为N，则N-1及之前的所有数据已被正确收到</li>
<li>数据偏移：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位</li>
<li>6个控制位：紧集位URG、确认位ACK、推送位PSH、复位RST、同步位SYN、终止位FIN</li>
<li>窗口：允许对方发送发送的数据量</li>
<li>检验和：检验首部+数据</li>
<li>紧集指针：URG=1时有意义，指出紧急数据的字节数</li>
<li>选项：最大报文段长度MSS、窗口扩大、时间戳、选择确认</li>
</ul>
<p>TCP连接管理——三次握手</p>
<ul>
<li>客户端发送连接请求报文段，无应用层数据（SYN=1，seq=x）</li>
<li>服务器端返回确认报文段，允许连接，无应用层数据（SYN=1，ACK=1，seq=y，ack=x+1)</li>
<li>客户端向服务器端返回确认的确认，可以携带数据（SYN=0，ACK=1，seq=x+1，ack=y+1)</li>
</ul>
<p>TCP连接管理——四次挥手</p>
<ul>
<li>客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接（FIN=1，seq=u）</li>
<li>服务器返回确认报文段，客户到服务器这个方向的连接就释放了（ACK=1，seq=v，ack=u+1）</li>
<li>服务器发送完数据，就发出连接释放报文段，主动关闭TCP连接（FIN=1，ACK=1，seq=w，ack=u+1）</li>
<li>客户端回送一个确认报文段，再等时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭（ACK=1，seq=u+1，ack=w+1）</li>
</ul>
<p>TCP可靠传输：</p>
<ul>
<li>校验、序号、确认、重传</li>
</ul>
<p>TCP流量控制：</p>
<ul>
<li>通过接收方的窗口rwnd来告诉发送方窗口</li>
<li>只要有零窗口通知，就启动持续计时器，到期时发送零窗口探测报文段，解决死锁问题</li>
</ul>
<p>TCP拥塞控制：</p>
<ul>
<li>慢开始和拥塞避免：从1开始指数规律增长，到上一轮最大值的一半，然后加法增大直到拥塞</li>
<li>快重传和快恢复：收到3个重复的确认就进行快重传，快恢复时降到一半开始加法增大直到3次重复</li>
</ul>
<h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6.应用层"></a>6.应用层</h1><h2 id="6-1应用层概述"><a href="#6-1应用层概述" class="headerlink" title="6.1应用层概述"></a>6.1应用层概述</h2><p>C/S与P2P</p>
<h2 id="6-2DNS"><a href="#6-2DNS" class="headerlink" title="6.2DNS"></a>6.2DNS</h2><p>DNS：将域名解析成IP地址</p>
<p>域名的结构：顶级域名cn，com；二级域名edu</p>
<p>域名解析：递归（靠别人）、迭代（靠自己）</p>
<h2 id="6-3FTP"><a href="#6-3FTP" class="headerlink" title="6.3FTP"></a>6.3FTP</h2><ul>
<li>基于C/S</li>
<li>匿名登录，使用TCP</li>
<li>传输方式：文本模式、二进制模式</li>
</ul>
<h2 id="6-4电子邮件"><a href="#6-4电子邮件" class="headerlink" title="6.4电子邮件"></a>6.4电子邮件</h2><p>SMTP：</p>
<ul>
<li>TCP连接，C/S</li>
<li>不能传送可执行文件或其他二进制对象</li>
<li>仅传送ASCII</li>
<li>拒绝超长邮件</li>
</ul>
<p>MIME：支持多媒体</p>
<p>POP3：下载并保留或下载并删除</p>
<p>IMAP：可以看到首部，打开后才传到计算机上</p>
<h2 id="6-5HTTP"><a href="#6-5HTTP" class="headerlink" title="6.5HTTP"></a>6.5HTTP</h2><p>URL统一资源定位符：协议+主机+端口+路径，不区分大小写</p>
<p>万维网：C/S</p>
<p>请求文档过程：</p>
<ul>
<li>浏览器分析URL</li>
<li>浏览器向DNS请求解析IP地址</li>
<li>DNS解析出IP地址</li>
<li>浏览器与服务器建立TCP连接</li>
<li>浏览器发出取文件命令</li>
<li>服务器响应</li>
<li>释放TCP连接</li>
<li>浏览器显示</li>
</ul>
<p>Cookie：存储在用户主机中的文本文件，记录访问记录</p>
<p>HTTP用TCP但是无连接</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/" data-id="ckcw27pel0000hwv24yscd780" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机组成原理复习提纲" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/" class="article-date">
  <time datetime="2020-07-20T08:41:07.922Z" itemprop="datePublished">2020-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/">计算机组成原理复习提纲</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-计算机组成原理概论"><a href="#1-计算机组成原理概论" class="headerlink" title="1.计算机组成原理概论"></a>1.计算机组成原理概论</h1><h2 id="1-1软硬件发展"><a href="#1-1软硬件发展" class="headerlink" title="1.1软硬件发展"></a>1.1软硬件发展</h2><p>四代计算机的逻辑元件：电子管、晶体管、中小规模集成电路、超大规模集成电路</p>
<p>机器字长：整数运算的二进制位数</p>
<h2 id="1-2计算机系统组成"><a href="#1-2计算机系统组成" class="headerlink" title="1.2计算机系统组成"></a>1.2计算机系统组成</h2><p>输入设备、输出设备、运算器、存储器、控制器</p>
<h2 id="1-3CPU工作过程"><a href="#1-3CPU工作过程" class="headerlink" title="1.3CPU工作过程"></a>1.3CPU工作过程</h2><p>CPU包括运算器和控制器</p>
<p>运算器：MQ、ACC、ALU、X、PSW</p>
<p>控制器：CU、IR、PC</p>
<p>取数指令过程：</p>
<ul>
<li>（PC）$\rightarrow$ MAR</li>
<li>M（MAR）$\rightarrow$ MDR</li>
<li>（MDR）$\rightarrow$ IR</li>
<li>OP（IR）$\rightarrow$ CU</li>
<li>Ad（IR）$\rightarrow$ MAR</li>
<li>M（MAR）$\rightarrow$ MDR</li>
<li>（MDR）$\rightarrow$ ACC</li>
</ul>
<p>CPU区分指令与数据的依据是指令周期的不同阶段</p>
<h2 id="1-4五层结构"><a href="#1-4五层结构" class="headerlink" title="1.4五层结构"></a>1.4五层结构</h2><ul>
<li>虚拟机器M4（高级）</li>
<li>虚拟机器M3（汇编）</li>
<li>虚拟机器M2（操作系统）</li>
<li>传统机器M1（机器）</li>
<li>微程序机器M0（硬件）</li>
</ul>
<h2 id="1-5冯诺依曼结构"><a href="#1-5冯诺依曼结构" class="headerlink" title="1.5冯诺依曼结构"></a>1.5冯诺依曼结构</h2><ul>
<li>五大部件</li>
<li>指令、数据存于存储器中，按地址寻址</li>
<li>二进制表示</li>
<li>指令由操作码与地址码组成</li>
<li>指令顺序存放，但执行顺序不固定</li>
<li>早期以运算器为中心</li>
</ul>
<h2 id="1-6性能指标"><a href="#1-6性能指标" class="headerlink" title="1.6性能指标"></a>1.6性能指标</h2><p>总容量=存储单元个数$\times$ 存储字长</p>
<p>CPI：执行一条指令所需周期数</p>
<p>MIPS：每秒执行多少百万条指令</p>
<p>IPS：主频/CPI</p>
<p>数据通路带宽：数据总线的传输位数</p>
<p>吞吐量：请求处理的速度</p>
<h1 id="2-数在计算机中的表示"><a href="#2-数在计算机中的表示" class="headerlink" title="2.数在计算机中的表示"></a>2.数在计算机中的表示</h1><h2 id="2-1数的进制与校验"><a href="#2-1数的进制与校验" class="headerlink" title="2.1数的进制与校验"></a>2.1数的进制与校验</h2><p>进制的转换：除r取余、乘r取整</p>
<p>BCD码：8421码（加6修正）、余3码（+011）、2421码（改变权值）</p>
<p>ASCII码：可印刷32~126</p>
<p>大端模式：高字节保存在低地址，小端模式相反</p>
<p>奇偶校验：奇校验保证1有奇数个，偶校验保证1有偶数个</p>
<p>海明码：公式：2^k&gt;n+k+1 k为校验位</p>
<p>循环冗余校验码：生成多项式</p>
<h2 id="2-2定点数"><a href="#2-2定点数" class="headerlink" title="2.2定点数"></a>2.2定点数</h2><p>负数的补码：符号位不变，数值位按位取反加1</p>
<p>加减运算的溢出判断：单符号位、双进位、双符号位</p>
<p>原码一位乘法，补码一位乘法，用双符号位处理溢出</p>
<p>强制类型转换：</p>
<ul>
<li>无符号数转成有符号数，不改变数据内容，改变解释方式</li>
<li>长到短：高位截断，保留低位</li>
<li>短到长：符号扩展，真值不变</li>
</ul>
<p>除法：恢复余数、不恢复余数</p>
<h2 id="2-3浮点数"><a href="#2-3浮点数" class="headerlink" title="2.3浮点数"></a>2.3浮点数</h2><p>表示：阶码+尾数</p>
<p>规格化：尾数最高位为有效值</p>
<p>下溢：机器0</p>
<p>上溢：报错</p>
<p>IEEE754标准：数符+阶码+尾数</p>
<ul>
<li>短1+8+23</li>
<li>长1+11+52</li>
</ul>
<p>浮点数的加减：</p>
<ul>
<li>转换格式</li>
<li>对阶，小阶向大阶看齐</li>
<li>尾数加减</li>
<li>规格化</li>
<li>舍入</li>
<li>判溢出</li>
</ul>
<h2 id="2-4加法器"><a href="#2-4加法器" class="headerlink" title="2.4加法器"></a>2.4加法器</h2><p>单级先行进位：组内并行，组间串行</p>
<p>多级线性进位：组内并行，组间并行</p>
<h1 id="3-存储"><a href="#3-存储" class="headerlink" title="3.存储"></a>3.存储</h1><h2 id="3-1RAM"><a href="#3-1RAM" class="headerlink" title="3.1RAM"></a>3.1RAM</h2><table>
<thead>
<tr>
<th align="left">——</th>
<th>SRAM</th>
<th>DRAM</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储信息</td>
<td>触发器</td>
<td>电容</td>
</tr>
<tr>
<td align="left">破坏性读出</td>
<td>非</td>
<td>是</td>
</tr>
<tr>
<td align="left">刷新</td>
<td>不要</td>
<td>需要</td>
</tr>
<tr>
<td align="left">行列地址</td>
<td>同时送</td>
<td>分两次送</td>
</tr>
<tr>
<td align="left">速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td align="left">集成度</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td align="left">发热</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td align="left">成本</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<p>SRAM常用作cache，DRAM常用作主存</p>
<p>DRAM刷新：</p>
<ul>
<li>不需要CPU控制，是存储器内部过程</li>
<li>刷新周期：2ms</li>
<li>以行为单位，每次刷新一行</li>
<li>读出后导入，占用一个读写周期</li>
<li>用行列地址，减少选通线数量</li>
<li>刷新策略：分散刷新、集中刷新、异步刷新</li>
</ul>
<p>SRAM读写：存取时间+恢复时间=存取周期</p>
<h2 id="3-2ROM"><a href="#3-2ROM" class="headerlink" title="3.2ROM"></a>3.2ROM</h2><p>非易失、位密度高</p>
<h2 id="3-3主存和CPU的连接"><a href="#3-3主存和CPU的连接" class="headerlink" title="3.3主存和CPU的连接"></a>3.3主存和CPU的连接</h2><p>位扩展：在数据总线上扩展</p>
<p>字扩展：在地址总线上扩展</p>
<p>字扩展（改）：采用译码片选法</p>
<p>注意电路结构的画法</p>
<h2 id="3-4双口RAM与多模块"><a href="#3-4双口RAM与多模块" class="headerlink" title="3.4双口RAM与多模块"></a>3.4双口RAM与多模块</h2><p>双端口冲突：置“忙”位</p>
<p>多体并行：流水线思想，微观上与宏观上的速度计算</p>
<h2 id="3-5cache"><a href="#3-5cache" class="headerlink" title="3.5cache"></a>3.5cache</h2><p>命中率的计算</p>
<p>地址映射的方式：全相连、直接映射、组映射</p>
<p>替换策略：RAND、FIFO、LRU（近期最少）、LFU（最不经常）</p>
<p>写回法：替换时再改主存，设置脏位</p>
<p>全写法：使用写缓冲</p>
<p>写分配法：先将主存中的块调入cache，然后改，配合写回法</p>
<p>非写分配法：只写入主存，不调入cache，配合全写法</p>
<h1 id="4-指令系统"><a href="#4-指令系统" class="headerlink" title="4.指令系统"></a>4.指令系统</h1><h2 id="4-1指令格式"><a href="#4-1指令格式" class="headerlink" title="4.1指令格式"></a>4.1指令格式</h2><p>四指令：访存4次</p>
<p>三指令：访存4次</p>
<p>二指令：访存4次</p>
<p>一指令：3次或2次</p>
<p>零指令：空操作符</p>
<p>扩展操作符：注意前缀，频率高的分配短操作码</p>
<h2 id="4-2寻址"><a href="#4-2寻址" class="headerlink" title="4.2寻址"></a>4.2寻址</h2><p>指令寻址：顺序或跳跃</p>
<p>数据寻址：</p>
<ul>
<li>隐含寻址</li>
<li>立即寻址</li>
<li>直接寻址</li>
<li>一次间接寻址</li>
<li>寄存器寻址</li>
<li>寄存器一次间接寻址</li>
<li>相对寻址</li>
<li>基址寻址</li>
<li>变址寻址</li>
<li>堆栈寻址</li>
</ul>
<h2 id="4-3CISC和RISC"><a href="#4-3CISC和RISC" class="headerlink" title="4.3CISC和RISC"></a>4.3CISC和RISC</h2><p>CISC：复杂，不固定指令字长，寄存器少，微程序控制</p>
<p>RISC：必须实现流水线，优化好，组合逻辑控制</p>
<h1 id="5-CPU"><a href="#5-CPU" class="headerlink" title="5.CPU"></a>5.CPU</h1><h2 id="5-1CPU功能"><a href="#5-1CPU功能" class="headerlink" title="5.1CPU功能"></a>5.1CPU功能</h2><p>指令控制、时间控制、数据加工、中断处理</p>
<h2 id="5-2指令周期数据流"><a href="#5-2指令周期数据流" class="headerlink" title="5.2指令周期数据流"></a>5.2指令周期数据流</h2><p>取指、间址、执行、中断</p>
<p>通过MAR调用MDR的过程</p>
<p>单指令周期：所有指令相同时间完成，串行</p>
<p>多指令周期：时间不同、串行</p>
<p>流水线：并行、各指令步骤不同</p>
<h2 id="5-3CPU单总线"><a href="#5-3CPU单总线" class="headerlink" title="5.3CPU单总线"></a>5.3CPU单总线</h2><p>寄存器间数据传送、主存与CPU间传递、执行算术或逻辑运算</p>
<h2 id="5-4硬布线"><a href="#5-4硬布线" class="headerlink" title="5.4硬布线"></a>5.4硬布线</h2><ul>
<li>分析微操作序列</li>
<li>选择CPU控制方式</li>
<li>安排时序</li>
<li>电路设计</li>
</ul>
<h2 id="5-5微程序"><a href="#5-5微程序" class="headerlink" title="5.5微程序"></a>5.5微程序</h2><p>水平型：操作控制+顺序控制</p>
<p>垂直型：微操作码+目的地址+源地址</p>
<p>混合型</p>
<p>编码方式：</p>
<ul>
<li>直接编码：每位代表一命令</li>
<li>字段直接编码：分段，每段译码后控制，留一位空操作</li>
<li>字段间接编码：需要段间解释，缩短了微指令字长，降低了并行能力</li>
</ul>
<h2 id="5-6流水线"><a href="#5-6流水线" class="headerlink" title="5.6流水线"></a>5.6流水线</h2><p>吞吐量、加速比、效率</p>
<p>影响流水线的因素：资源冲突、数据冲突、控制冲突</p>
<p>多发技术：</p>
<ul>
<li>超标量：每个时钟周期内并发多条指令</li>
<li>超流水：一个时钟周期再分段</li>
<li>超长指令字：各条并行指令合为一条</li>
</ul>
<h1 id="6-总线"><a href="#6-总线" class="headerlink" title="6.总线"></a>6.总线</h1><h2 id="6-1总线概念及分类"><a href="#6-1总线概念及分类" class="headerlink" title="6.1总线概念及分类"></a>6.1总线概念及分类</h2><p>特性：</p>
<ul>
<li>机械（尺寸形状）</li>
<li>电气（传输方向、电平）</li>
<li>功能（数据、地址、控制）</li>
<li>时间（时序）</li>
</ul>
<p>分类：</p>
<ul>
<li>串行、并行</li>
<li>片内、系统、通信</li>
<li>同步、异步</li>
</ul>
<p>结构：单总线、双总线、三总线</p>
<h2 id="6-2总线仲裁"><a href="#6-2总线仲裁" class="headerlink" title="6.2总线仲裁"></a>6.2总线仲裁</h2><p>集中仲裁：链式、计数器、独立</p>
<p>分布仲裁</p>
<h2 id="6-3总线操作和定时"><a href="#6-3总线操作和定时" class="headerlink" title="6.3总线操作和定时"></a>6.3总线操作和定时</h2><p>传输过程：申请分配、寻址、传输、结束</p>
<p>定时：</p>
<ul>
<li>同步定时</li>
<li>异步定时：不互锁、半互锁、全互锁</li>
<li>半同步</li>
<li>分离</li>
</ul>
<p>波特率针对所有数据，比特率针对有效数据</p>
<h1 id="7-I-O"><a href="#7-I-O" class="headerlink" title="7.I/O"></a>7.I/O</h1><h2 id="7-1I-O方式"><a href="#7-1I-O方式" class="headerlink" title="7.1I/O方式"></a>7.1I/O方式</h2><p>程序查询：I/O与CPU串行</p>
<p>程序中断：CPU继续工作</p>
<p>DMA：DMA控制器</p>
<p>通道：I/O指令启动通道</p>
<h2 id="7-2外存储器"><a href="#7-2外存储器" class="headerlink" title="7.2外存储器"></a>7.2外存储器</h2><p>磁盘：磁头数、柱面数、扇区数</p>
<p>平均存取：寻道+旋转+传输</p>
<p>RAID1~5：冗余</p>
<h2 id="7-3I-O接口"><a href="#7-3I-O接口" class="headerlink" title="7.3I/O接口"></a>7.3I/O接口</h2><p>功能：设备选址、传送命令、传送数据、反映I/O状态</p>
<p>结构：设备选择电路、命令寄存器、命令译码器、数据缓冲存储、设备状态标记、控制逻辑电路、内部接口（只能并行）、外部接口</p>
<p>编址方式：统一编址（与存储器共用）、独立编址（I/O专门编址）</p>
<h2 id="7-4I-O方式"><a href="#7-4I-O方式" class="headerlink" title="7.4I/O方式"></a>7.4I/O方式</h2><p>中断：</p>
<ul>
<li>中断隐指令：关中断、保存断点、送中断向量</li>
<li>中断服务程序：保护现场、执行中断服务程序、恢复现场、开中断、中断返回</li>
</ul>
<p>中断判优：</p>
<ul>
<li>硬件&gt;软件</li>
<li>非屏蔽&gt;可屏蔽</li>
<li>DMA&gt;I/O</li>
<li>高速&gt;低速</li>
<li>输入&gt;输出</li>
<li>实时设备&gt;普通设备</li>
</ul>
<p>DMA方式：</p>
<p>硬件控制、优先级高于中断、仅传递数据</p>
<p>DMA传送过程：</p>
<ul>
<li>预处理：CPU完成寄存器初值设置等准备工作</li>
<li>数据传送：CPU继续执行主程序，DMA控制器完成数据传送</li>
<li>后处理：CPU执行中断服务程序做DMA结束处理</li>
</ul>
<p>DMA传送方式：</p>
<ul>
<li>停止CPU访存：需要数据传送时，停止CPU访存，总线控制权交给DMA控制器</li>
<li>交替访存：将CPU周期分为DMA访存和CPU访存两个部分</li>
<li>周期挪用：I/O设备需要访存时，挪用一个或几个存取周期</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/" data-id="ckcu9f4r20000rcv292c25ify" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-操作系统复习提纲" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/" class="article-date">
  <time datetime="2020-07-19T15:51:35.759Z" itemprop="datePublished">2020-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/">操作系统复习提纲</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1.操作系统概述"></a>1.操作系统概述</h1><h2 id="1-1操作系统的概念"><a href="#1-1操作系统的概念" class="headerlink" title="1.1操作系统的概念"></a>1.1操作系统的概念</h2><p>操作系统概念：负责管理协调硬件、软件等资源的工作，为上层用户、应用程序提供服务的一种系统软件</p>
<p>功能：处理机管理、存储器管理、文件管理、设备管理</p>
<p>命令接口：允许用户直接使用</p>
<p>程序接口：允许用户通过程序间接使用，由系统调用组成</p>
<h2 id="1-2操作系统的特征"><a href="#1-2操作系统的特征" class="headerlink" title="1.2操作系统的特征"></a>1.2操作系统的特征</h2><ul>
<li>并发：宏观上同时发生，微观上交替发生</li>
<li>共享：计算机中的资源可供内存中多个并发执行的进程共同使用</li>
<li>虚拟：把物理上的实体变为若干个逻辑上的对应物，让用户感觉到超出真实实体的性能</li>
<li>异步：进程执行并非是连续的，而是以不可预知的速度进行</li>
</ul>
<p>并发与共享互为存在条件，并发性和共享性是虚拟和异步的基础</p>
<h2 id="1-3操作系统的发展"><a href="#1-3操作系统的发展" class="headerlink" title="1.3操作系统的发展"></a>1.3操作系统的发展</h2><p>四个阶段：</p>
<ul>
<li>手工操作阶段</li>
<li>批处理阶段</li>
<li><ul>
<li>单道批处理系统：提升效率，但是CPU等待I/O</li>
<li>多道批处理系统：并发执行，没有人机交互功能</li>
</ul>
</li>
<li>分时操作系统</li>
<li><ul>
<li>以时间片为单位轮流为各个用户服务，人机可交互，可立即对请求作出响应，但是不能优先处理紧急任务</li>
</ul>
</li>
<li>实时操作系统</li>
<li><ul>
<li>能够优先响应紧急任务，具有及时性和可靠性</li>
</ul>
</li>
</ul>
<h2 id="1-4操作系统的运行机制与体系结构"><a href="#1-4操作系统的运行机制与体系结构" class="headerlink" title="1.4操作系统的运行机制与体系结构"></a>1.4操作系统的运行机制与体系结构</h2><p>特权指令：不允许用户使用</p>
<p>非特权指令：普通的指令</p>
<p>用户态：用户只能执行非特权指令</p>
<p>核心态：特权指令与非特权指令都可以执行</p>
<p>内核程序：既可以执行特权指令，也可以执行非特权指令，运行在核心态</p>
<p>应用程序：只能执行非特权指令，运行在用户态</p>
<p>大内核：</p>
<ul>
<li>将操作系统的主要功能都作为系统内核，运行在核心态</li>
<li>优点：高性能</li>
<li>缺点：内核代码庞大，结构混乱，难以维护</li>
</ul>
<p>微内核：</p>
<ul>
<li>只把最基本的功能保留在内核</li>
<li>优点：内核功能少，结构清晰，方便维护</li>
<li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li>
</ul>
<h2 id="1-5中断和异常"><a href="#1-5中断和异常" class="headerlink" title="1.5中断和异常"></a>1.5中断和异常</h2><ul>
<li>中断发生时，系统立刻进入核心态</li>
<li>中断发生后，当前运行的进程暂停运行，由操作系统的内核对中断进行处理</li>
<li>对于不同的中断信号，会进行不同的处理</li>
</ul>
<p>中断是用户态到核心态的唯一途径</p>
<p>核心态到用户态是通过执行一个特权指令，将程序状态字的标志位设置为“用户态”</p>
<p>中断分为外中断和内中断</p>
<p>中断的处理过程：</p>
<ul>
<li>执行完每个指令后，CPU都要检查当前是否有外部中断信号</li>
<li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境</li>
<li>根据中断信号类型转入响应的中断处理程序</li>
<li>恢复原进程的CPU环境并退出中断，返回原进程继续向下执行</li>
</ul>
<h2 id="1-6系统调用"><a href="#1-6系统调用" class="headerlink" title="1.6系统调用"></a>1.6系统调用</h2><p>系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数。</p>
<p>系统调用的功能：</p>
<ul>
<li>设备管理</li>
<li>文件管理</li>
<li>进程管理</li>
<li>进程通信</li>
<li>内存管理</li>
</ul>
<p>系统调用的相关处理在核心态下进行</p>
<p>系统调用的过程：</p>
<ul>
<li>传递系统调用参数</li>
<li>执行陷入指令（用户态）</li>
<li>执行系统调用响应服务程序（核心态）</li>
<li>返回用户程序</li>
</ul>
<p>系统调用和库函数的区别：</p>
<ul>
<li>系统调用是操作系统向上层提供的接口</li>
<li>有的库函数是对系统调用的进一步封装</li>
<li>当今编写的应用程序大多数是通过高级语言提供的库函数间接地进行系统调用</li>
</ul>
<h1 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h1><h2 id="2-1进程的定义、组成"><a href="#2-1进程的定义、组成" class="headerlink" title="2.1进程的定义、组成"></a>2.1进程的定义、组成</h2><p>进程实体由进程控制块PCB、程序段、数据段组成</p>
<p>PCB是进程存在的唯一标志</p>
<p>进程是具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位</p>
<p>进程实体是静态的，进程是动态的，但是一般不做区分</p>
<p>PCB：</p>
<ul>
<li>进程描述信息</li>
<li>进程控制和管理信息</li>
<li>资源分配清单</li>
<li>处理机相关信息</li>
</ul>
<p>进程的组织形式：</p>
<ul>
<li>链接方式：按进程状态将PCB划分为多个队列</li>
<li>索引方式：按进程状态建立几张索引表，各表项指向一个PCB</li>
</ul>
<p>进程的特征：</p>
<ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性：资源分配、调度的独立单位</li>
<li>异步性：导致结果的不确定性</li>
<li>结构性</li>
</ul>
<h2 id="2-2进程的状态与转换"><a href="#2-2进程的状态与转换" class="headerlink" title="2.2进程的状态与转换"></a>2.2进程的状态与转换</h2><p>进程的状态：</p>
<ul>
<li>运行状态</li>
<li>就绪状态</li>
<li>阻塞状态</li>
<li>创建状态</li>
<li>终止状态</li>
</ul>
<p>进程状态间的转换</p>
<ul>
<li>就绪态$\rightarrow$ 运行态：进程被调度</li>
<li>运行态$\rightarrow$ 就绪态：时间片到，或被高优先级的进程抢占</li>
<li>运行态$\rightarrow$ 阻塞态：等待系统资源分配，或等待某事件发生</li>
<li>阻塞态$\rightarrow$ 就绪态：资源分配到位，等待的事件发生</li>
</ul>
<p>从运行态进入阻塞态是进程主动请求的</p>
<h2 id="2-3进程控制"><a href="#2-3进程控制" class="headerlink" title="2.3进程控制"></a>2.3进程控制</h2><p>进程控制实现的方式是原语</p>
<p>原语的特点是不允许中断，采用“关中断指令”与“开中断指令”实现</p>
<p>原语运行在核心态</p>
<p>原语要做的事情：</p>
<ul>
<li>更新PCB中的信息</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ul>
<h2 id="2-4进程通信"><a href="#2-4进程通信" class="headerlink" title="2.4进程通信"></a>2.4进程通信</h2><p>进程通信指进程之间的信息交换</p>
<p>一个进程不能直接访问另一个进程的地址空间</p>
<ul>
<li>共享存储：必须保证互斥性</li>
<li><ul>
<li>基于数据结构共享：低级，速度慢，限制多</li>
<li>基于存储区共享：高级，速度更快，在内存中划出共享存储区，由进程控制</li>
</ul>
</li>
<li>管道通信：在内存中开辟一个缓冲区</li>
<li><ul>
<li>只能采用半双工通信</li>
<li>保持互斥性</li>
<li>管道容量限制使得可能发生阻塞</li>
<li>如果没写满，就不允许读；如果没读空，就不允许写</li>
<li>一旦被读，就被抛弃，因此读进程最多有一个</li>
</ul>
</li>
<li>消息传递：以格式化消息为单位，系统提供“发送/接受原语”<ul>
<li>直接通信：消息直接挂到进程的消息缓冲队列上</li>
<li>间接通信：消息先发送到中间实体中</li>
</ul>
</li>
</ul>
<h2 id="2-5线程"><a href="#2-5线程" class="headerlink" title="2.5线程"></a>2.5线程</h2><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</p>
<p>引入线程之后，提高了系统的并发度</p>
<p>线程是处理机的分配单元，是调度的基本单位</p>
<p>线程几乎不拥有系统资源，切换线程的系统开销要小得多</p>
<p>线程的实现方式：</p>
<ul>
<li>用户级线程：由应用程序负责，在用户态下完成，对操作系统透明</li>
<li>内核级线程：由操作系统内核完成，在核心态下完成 ，对操作系统不透明</li>
<li>当两者结合时，操作系统也只以内核级线程数量为准</li>
</ul>
<p>多线程模型问题：</p>
<ul>
<li>多对一：开销小，效率高，无法并行</li>
<li>一对一：成本大，可并行</li>
<li>多对多：两者的折中</li>
</ul>
<h2 id="2-6处理机调度"><a href="#2-6处理机调度" class="headerlink" title="2.6处理机调度"></a>2.6处理机调度</h2><p>由于资源有限，因此需要决定任务进行的顺序，需要处理机调度</p>
<p>调度的三个层次：</p>
<ul>
<li>高级调度（作业调度）：从后备队列的作业中挑一个作业，分配内存等资源，并建立响应的进程，是辅存与内存间的调度，调入时创建PCB，调出时撤销PCB</li>
<li>中级调度（内存调度）：决定将哪个处于挂起状态的进程调入内存，可能反复调度多次某进程</li>
<li>低级调度（进程调度）：从就绪队列中选取一个进程，分配处理机，发生在内存到CPU</li>
</ul>
<h2 id="2-7进程调度"><a href="#2-7进程调度" class="headerlink" title="2.7进程调度"></a>2.7进程调度</h2><p>进程调度的时机：</p>
<ul>
<li>进程主动或被动放弃处理机时，需要进程调度</li>
<li>不能进行进程调度的情况：</li>
<li><ul>
<li>处理中断</li>
<li>进程在操作系统内核程序临界区中（注意不是普通的临界区）</li>
<li>原语操作中</li>
</ul>
</li>
</ul>
<p>进程切换过程：</p>
<ul>
<li>对原来运行的进程各种数据的保存</li>
<li>对新进程各种数据的恢复</li>
</ul>
<p>进程切换是有代价的</p>
<p>进程调度方式：</p>
<ul>
<li>非剥夺调度方式</li>
<li>剥夺调度方式</li>
</ul>
<h2 id="2-8调度算法的评价指标"><a href="#2-8调度算法的评价指标" class="headerlink" title="2.8调度算法的评价指标"></a>2.8调度算法的评价指标</h2><ul>
<li>CPU利用率=忙碌的时间/总时间</li>
<li>系统吞吐量=作业量/时间</li>
<li>周转时间=作业完成时间-作业提交时间</li>
<li>带权周转时间=作业周转时间/作业实际运行时间</li>
<li>等待时间：等待被服务的时间</li>
<li>响应时间：从用户提交请求到首次响应的时间</li>
</ul>
<h2 id="2-9调度算法"><a href="#2-9调度算法" class="headerlink" title="2.9调度算法"></a>2.9调度算法</h2><p>先来先服务（FCFS）</p>
<ul>
<li>非抢占、实现简单、对短作业不利、不会饥饿</li>
</ul>
<p>短作业优先（SJF）</p>
<ul>
<li>默认非抢占、最短的平均等待时间、对长作业不利、会导致饥饿、运行时间由用户提供不一定真实</li>
</ul>
<p>高响应比优先（HRRN）</p>
<ul>
<li>响应比=（等待时间+要求服务时间）/要求服务时间</li>
<li>非抢占、不会饥饿，是前两种算法折中的结果</li>
</ul>
<p>时间片轮转（RR）</p>
<ul>
<li>抢占、公平、切换频繁、不会饥饿</li>
</ul>
<p>优先级调度</p>
<ul>
<li>抢占或非抢占、可能饥饿</li>
</ul>
<p>多级反馈队列</p>
<ul>
<li>很复杂，是多种算法的平衡，可能导致饥饿</li>
</ul>
<h2 id="2-10进程同步与互斥"><a href="#2-10进程同步与互斥" class="headerlink" title="2.10进程同步与互斥"></a>2.10进程同步与互斥</h2><p>同步是进程间的直接制约关系</p>
<p>互斥是保护临界资源的必要原则</p>
<p>互斥的四个部分：进入区、临界区、退出区、剩余区</p>
<p>互斥原则：空闲让进、忙则等待、有限等待、让权等待</p>
<h2 id="2-11进程互斥的软件实现方法"><a href="#2-11进程互斥的软件实现方法" class="headerlink" title="2.11进程互斥的软件实现方法"></a>2.11进程互斥的软件实现方法</h2><p>单标志法：在完全访问完临界区后将临界区权限转交给另一进程，即权限链式赋予，但是违背“空闲让进”原则</p>
<p>双标志先检查法：先检查一遍其他进程的意愿，违背“忙则等待”原则</p>
<p>双标志后检查法：先上锁后检查，违背”空闲让进“和”有限等待“，产生饥饿</p>
<p>Peterson算法：主动谦让，最后一个说客气话的循环等待，违背“让权等待”原则</p>
<h2 id="2-12进程互斥的硬件实现方法"><a href="#2-12进程互斥的硬件实现方法" class="headerlink" title="2.12进程互斥的硬件实现方法"></a>2.12进程互斥的硬件实现方法</h2><p>中断屏蔽方法：利用“开/关中断指令实现，简单高效，只适用于单处理机，只适用于内核进程</p>
<p>TestAndSet：违背”让权等待“，实现简单，适用于多处理机</p>
<p>Swap指令：违背”让权等待“，实现简单，适用于多处理机</p>
<h2 id="2-13信号量机制"><a href="#2-13信号量机制" class="headerlink" title="2.13信号量机制"></a>2.13信号量机制</h2><p>整型信号量：违背“让权等待”，PV操作</p>
<p>记录型信号量：遵循“让权等待”，PV操作、block和wakeup</p>
<h2 id="2-14信号量机制实现"><a href="#2-14信号量机制实现" class="headerlink" title="2.14信号量机制实现"></a>2.14信号量机制实现</h2><p>实现进程互斥：</p>
<ul>
<li>划定临界区</li>
<li>设置互斥信号量，初值为1</li>
<li>临界区前执行P</li>
<li>临界区后执行V</li>
</ul>
<p>注意：对不同的临界资源需要设置不同的互斥信号量</p>
<p>实现进程同步：</p>
<ul>
<li>设置同步信号量，初值为0</li>
<li>前操作之后执行V</li>
<li>后操作之前执行P</li>
</ul>
<p>实现前驱关系：多个同步问题叠加</p>
<h2 id="2-15生产者消费者问题"><a href="#2-15生产者消费者问题" class="headerlink" title="2.15生产者消费者问题"></a>2.15生产者消费者问题</h2><p>一个互斥量控制访问，两个同步量控制产品数和空位数</p>
<p>注意实现互斥的P一定要在实现同步的P之后</p>
<p>而两个V操作的顺序可以互换</p>
<h2 id="2-16多生产者多消费者问题"><a href="#2-16多生产者多消费者问题" class="headerlink" title="2.16多生产者多消费者问题"></a>2.16多生产者多消费者问题</h2><p>若缓冲区容量为1，一般可省去互斥量</p>
<h2 id="2-17吸烟者问题"><a href="#2-17吸烟者问题" class="headerlink" title="2.17吸烟者问题"></a>2.17吸烟者问题</h2><p>生产者消费者问题变种，注意缓冲区为1</p>
<h2 id="2-18读者写者问题"><a href="#2-18读者写者问题" class="headerlink" title="2.18读者写者问题"></a>2.18读者写者问题</h2><p>核心思想是设置了一个计数器来记录当前正在访问共享文件的读进程数</p>
<p>对计数器的检查和赋值不能同时进行会引入错误，可用互斥信号量来解决</p>
<h2 id="2-19哲学家进餐问题"><a href="#2-19哲学家进餐问题" class="headerlink" title="2.19哲学家进餐问题"></a>2.19哲学家进餐问题</h2><p>解决死锁</p>
<p>三种思路：</p>
<ul>
<li>减少抢占资源的最大人数</li>
<li>事先规定每个人的抢占顺序</li>
<li>抢占资源前先判断能否拿到所有资源</li>
</ul>
<h2 id="2-20管程"><a href="#2-20管程" class="headerlink" title="2.20管程"></a>2.20管程</h2><p>管程结构：</p>
<ul>
<li>局部于管程的共享数据结构</li>
<li>对该数据结构进行操作的一组函数</li>
<li>对局部于管程的共享数据结构设置初始值的语句</li>
<li>管程有一个名字</li>
</ul>
<p>管程的基本特征：</p>
<ul>
<li>局部于管程的数据只能被局部于管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li>每次仅允许一个进程在管程内执行某个内部过程</li>
</ul>
<h2 id="2-21死锁的概念"><a href="#2-21死锁的概念" class="headerlink" title="2.21死锁的概念"></a>2.21死锁的概念</h2><ul>
<li>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法推进</li>
<li>饥饿：由于长期得不到资源，导致进程无法推进</li>
<li>死循环：进程执行中一直无法跳出循环</li>
</ul>
<p>死锁的必要条件：</p>
<ul>
<li>互斥</li>
<li>不剥夺</li>
<li>请求和保持</li>
<li>循环等待</li>
</ul>
<p>什么时候回发生死锁：</p>
<ul>
<li>对不可剥夺资源的竞争（如打印机）</li>
<li>进程推进顺序非法，请求和释放资源的顺序不当</li>
<li>信号量的使用不当</li>
</ul>
<p>死锁的处理策略：</p>
<ul>
<li>预防死锁，破坏死锁的必要形成条件</li>
<li>避免死锁：防止系统进入不安全状态（银行家算法）</li>
<li>死锁的检测和解除：操作系统检查出死锁的发生，然后采取措施</li>
</ul>
<h2 id="2-22死锁的处理策略——预防死锁"><a href="#2-22死锁的处理策略——预防死锁" class="headerlink" title="2.22死锁的处理策略——预防死锁"></a>2.22死锁的处理策略——预防死锁</h2><ul>
<li>破坏互斥：将互斥资源改造为共享资源，如SPOOLing技术</li>
<li>破坏不剥夺：主动放弃已有资源或强行剥夺其他资源，但可能会导致饥饿，增加系统开销，会导致已有工作失效</li>
<li>破坏请求与保持：静态分配，一次分配所需资源，会导致饥饿，效率低</li>
<li>破坏循环等待：预先指定请求资源的顺序，不方便增加设备，资源浪费，编程复杂</li>
</ul>
<h2 id="2-23死锁的处理策略——避免死锁"><a href="#2-23死锁的处理策略——避免死锁" class="headerlink" title="2.23死锁的处理策略——避免死锁"></a>2.23死锁的处理策略——避免死锁</h2><p>银行家算法：</p>
<ul>
<li>检查申请是否超过了之前声明的最大需求数</li>
<li>检查此时系统剩余的可用资源是否能满足这次请求</li>
<li>试探着分配，更改各数据</li>
<li>用安全性算法检查分配是否会导致系统进入不安全状态</li>
</ul>
<p>安全性算法：检查当前的剩余可用资源是否能够满足某个进程的最大需求，如果可以，就把进程加入安全队列，并把该进程的所有资源全部回收。不断重复这一过程，看最终是否能让所有进程都加入安全序列</p>
<p>系统处于不安全状态不一定会死锁，处于安全状态一定不会死锁</p>
<h2 id="2-24死锁的处理策略——检测和解除"><a href="#2-24死锁的处理策略——检测和解除" class="headerlink" title="2.24死锁的处理策略——检测和解除"></a>2.24死锁的处理策略——检测和解除</h2><p>检测：资源分配图的削边法，依次消除与不阻塞进程相连的边，最后连着边的进程就是死锁进程</p>
<p>解除：对死锁进程进行资源剥夺、撤销或回退</p>
<h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3.内存管理"></a>3.内存管理</h1><h2 id="3-1内存的基础知识"><a href="#3-1内存的基础知识" class="headerlink" title="3.1内存的基础知识"></a>3.1内存的基础知识</h2><p>从写程序到程序运行：编译$\rightarrow$  链接$\rightarrow$ 装入</p>
<p>三种装入方式：</p>
<ul>
<li>绝对装入：在编译时就知道程序在内存中的位置，只适用于单道程序环境</li>
<li>静态重定位：根据装入的起始位置计算物理地址，装入时必须分配所有内存空间，在运行期间不能移动</li>
<li>动态重定位：使用重定位寄存器，允许程序在内存中发生移动</li>
</ul>
<p>三种链接方式：</p>
<ul>
<li>静态链接：先链接后装入</li>
<li>装入时动态链接：边装入边链接</li>
<li>运行时动态链接：需要执行时才进行链接，便于修改和更新，便于实现对目标模块的共享</li>
</ul>
<h2 id="3-2内存管理的概念"><a href="#3-2内存管理的概念" class="headerlink" title="3.2内存管理的概念"></a>3.2内存管理的概念</h2><ul>
<li>操作系统负责内存空间的分配与回收</li>
<li>操作系统需要从逻辑上对内存空间进行扩充</li>
<li>操作系统需要提供地址转换功能</li>
<li>操作系统需要提供内存保护功能</li>
</ul>
<p>内存保护的两种方式：设置上下限寄存器、界地址寄存器</p>
<h2 id="3-3覆盖与交换"><a href="#3-3覆盖与交换" class="headerlink" title="3.3覆盖与交换"></a>3.3覆盖与交换</h2><p>覆盖技术：程序大小超过内存总和，使用覆盖技术，将不常用的程序段放在覆盖区，对用户不透明，已弃用</p>
<p>交换技术：内存紧张时，换出某些进程，换出的进程放在对换区（I/O速度比文件区快）</p>
<p>区别：覆盖是在同一个进程中的，交换是不同进程之间的</p>
<h2 id="3-4连续分配管理方式"><a href="#3-4连续分配管理方式" class="headerlink" title="3.4连续分配管理方式"></a>3.4连续分配管理方式</h2><p>单一连续分配：只支持单道程序，用户程序放在用户区，无外部碎片，有内部碎片</p>
<p>固定分区分配：支持多道程序，每个分区只能装一道作业，无外部碎片，有内部碎片，有分区大小相等和不等两种方式</p>
<p>动态分区分配：动态建立分区，无内部碎片，有外部碎片</p>
<p>用于管理空闲分区的数据结构——空闲分区表、空闲分区链</p>
<h2 id="3-5动态分区分配算法"><a href="#3-5动态分区分配算法" class="headerlink" title="3.5动态分区分配算法"></a>3.5动态分区分配算法</h2><ul>
<li>首次适应：从头到尾找适合的分区，算法开销小，综合性能最好</li>
<li>最佳适应：优先使用更小的分区，算法开销大，产生大量小碎片</li>
<li>最坏适应：优先使用更大的，算法开销大，不利于大进程</li>
<li>邻近适应：从上次查找结束位置开始查找，算法开销小，但会使高地址的大分区也被用完</li>
</ul>
<h2 id="3-6基本分页存储管理的概念"><a href="#3-6基本分页存储管理的概念" class="headerlink" title="3.6基本分页存储管理的概念"></a>3.6基本分页存储管理的概念</h2><p>思想：把进程分页，各个页面离散地放到内存块中</p>
<p>概念：页框、页、页号</p>
<p>实现地址转换：</p>
<ul>
<li>计算出逻辑地址对应的页号</li>
<li>找到对应页面在内存中的位置</li>
<li>算出页内偏移量</li>
<li>物理地址=页面地址+页内偏移量</li>
</ul>
<p>计算：页号=逻辑地址/页面大小；页内偏移量=逻辑地址%页面大小</p>
<p>页表：</p>
<ul>
<li>页表记录进程页面和实际存放的内存块之间的对应关系</li>
<li>一个进程对应一张页表，进程的每一页对应一个页表项，页表项由页号和块号组成</li>
<li>每个页表项的长度是相同的，页号是隐含的</li>
</ul>
<h2 id="3-7基本地址变换机构"><a href="#3-7基本地址变换机构" class="headerlink" title="3.7基本地址变换机构"></a>3.7基本地址变换机构</h2><p>页表寄存器的作用：存放页表起始地址，存放页表长度</p>
<p>地址变换过程：</p>
<ul>
<li>根据逻辑地址算出页号、页内偏移量</li>
<li>页号的合法性检查</li>
<li>若页号合法，再根据页表起始地址、页号找到对应页表项</li>
<li>根据页表项中的内存块号、页内偏移量得到最终的物理地址</li>
<li>访问存储单元</li>
</ul>
<p>小细节：</p>
<ul>
<li>页内偏移量与页面大小的关系</li>
<li>页式管理中地址是一维的</li>
<li>实际应用中，通常使一个页框恰好能放入整数个页表项</li>
<li>为了方便找到页表项，页表一般是放在连续的内存块中的</li>
</ul>
<h2 id="3-8具有快表的地址变换机构"><a href="#3-8具有快表的地址变换机构" class="headerlink" title="3.8具有快表的地址变换机构"></a>3.8具有快表的地址变换机构</h2><p>地址变换过程：</p>
<ul>
<li>根据逻辑地址算出页号、页内偏移量</li>
<li>页号的合法性检查</li>
<li>查快表，若命中则跳过查页表</li>
<li>查页表，再根据页表起始地址、页号找到对应页表项，并将页表项复制到快表中</li>
<li>根据页表项中的内存块号、页内偏移量得到最终的物理地址</li>
<li>访问存储单元</li>
</ul>
<p>快表命中，则访存一次；未命中，则访存两次</p>
<h2 id="3-9基本分段存储管理方式"><a href="#3-9基本分段存储管理方式" class="headerlink" title="3.9基本分段存储管理方式"></a>3.9基本分段存储管理方式</h2><p>段表中还含有段长</p>
<p>地址变换时，还需考虑段内地址是否越界</p>
<p>分页VS分段：</p>
<ul>
<li>分页对用户不可见，分段对用户可见</li>
<li>分页的地址空间是一维的，分段的地址空间是二维的</li>
<li>分段更容易实现信息的共享和保护</li>
<li>分页与分段访问一个逻辑地址都需要两次访存，分段存储也可引入快表</li>
</ul>
<h2 id="3-10段页式管理方式"><a href="#3-10段页式管理方式" class="headerlink" title="3.10段页式管理方式"></a>3.10段页式管理方式</h2><p>分页难以实现信息的共享和保护，分段会产生外部碎片</p>
<p>段表需存储页表长度和页表存放地址</p>
<p>地址变换时需要检查页号是否越界</p>
<p>访存三次：查段表、查页表、访问目标单元</p>
<p>可引入快表机构，以段号和页号为关键字查询快表，命中时仅需一次访存</p>
<h2 id="3-11虚拟内存的基本概念"><a href="#3-11虚拟内存的基本概念" class="headerlink" title="3.11虚拟内存的基本概念"></a>3.11虚拟内存的基本概念</h2><p>特征：多次性、对换性、虚拟性</p>
<p>建立在离散分配的基础上</p>
<h2 id="3-12请求分页管理方式"><a href="#3-12请求分页管理方式" class="headerlink" title="3.12请求分页管理方式"></a>3.12请求分页管理方式</h2><p>在基本分页的基础上增加了几个表项：</p>
<ul>
<li>状态位：页面是否已在内存中</li>
<li>访问字段：记录最近被访问过几次，或记录上次访问的时间</li>
<li>修改位：表示页面调入内存后是否被修改过，只有修改过的页面才需在置换时写回外存</li>
<li>外存地址：页面在外存中的地址</li>
</ul>
<p>缺页中断机构：</p>
<ul>
<li>找到页表项后检查页面是否已经在内存，若没在内存，产生缺页中断</li>
<li>缺页中断处理中，需要将目标页面调入内存，有必要时还要换出页面</li>
<li>缺页中断属于内中断的“故障”，即可能被系统修复的异常</li>
<li>一条指令在执行过程中可能产生多次缺页中断</li>
</ul>
<p>地址变换机构：</p>
<ul>
<li>找到页表项需要检查页面是否在内存中</li>
<li>若页面不在内存中，需要请求调页</li>
<li>若内存空间不够，需要换出页面</li>
<li>页面调出内存后，需要修改相应页表项</li>
</ul>
<h2 id="3-13页面置换算法"><a href="#3-13页面置换算法" class="headerlink" title="3.13页面置换算法"></a>3.13页面置换算法</h2><ul>
<li>OPT：优先淘汰最长时间内不会被访问的页面，缺页率最小，但无法实现</li>
<li>FIFO：优先淘汰最先进入内存的页面，实现简单，可能出现Belady异常（增大块数反而缺页次数增加）</li>
<li>LRU：优先淘汰最近最久没访问的页面，性能很好，但是算法开销大</li>
<li>CLOCK：循环扫描各页面，扫0，开销小，但是没有考虑页面是否被修改</li>
<li>改进型CLOCK：四轮淘汰：（0,0），（0,1）且将扫描过的页面访问位置0，（0,0），（0,1），算法开销小，性能也不错</li>
</ul>
<h2 id="3-14页面分配策略"><a href="#3-14页面分配策略" class="headerlink" title="3.14页面分配策略"></a>3.14页面分配策略</h2><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合</p>
<p>固定分配局部置换：缺页时换出进程自己的某页</p>
<p>可变分配全局置换：只要缺页就分配新物理块</p>
<p>可变分配局部置换：根据缺页率动态分配物理块</p>
<p>何时调入页面：</p>
<ul>
<li>预调页策略：一般用于进程运行前</li>
<li>请求调页策略：进程运行时，发现缺页再调页</li>
</ul>
<p>从何处调页：</p>
<ul>
<li>对换区——采用连续存储，速度快；文件区——采用离散存储，速度慢</li>
<li>对换区够大：运行时将数据从文件区复制到对换区</li>
<li>对换区不够大：不会修改的数据每次都从文件区调入，会修改的数据调出到对换区，需要时再调入</li>
<li>UNIX方式：第一次使用的页面都从文件区调入，调回的页面都写回对换区，再次使用时从对换区调入</li>
</ul>
<p>抖动（颠簸）现象：页面平凡换入换出，主要原因是分配给进程的物理块不够</p>
<p>工作集：在某段时间间隔里，进程实际访问页面的集合，驻留集大小一般不能小于工作集大小</p>
<h1 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4.文件管理"></a>4.文件管理</h1><h2 id="4-1文件的逻辑结构"><a href="#4-1文件的逻辑结构" class="headerlink" title="4.1文件的逻辑结构"></a>4.1文件的逻辑结构</h2><p>无结构文件：由二进制或字符流组成，无明显的逻辑结构</p>
<p>有结构文件：由记录组成，分为定长记录、可变长记录</p>
<p>顺序文件：</p>
<ul>
<li>分为串结构和顺序结构</li>
<li>可变长记录的顺序文件无法实现随机存取，定长记录可以</li>
<li>定长记录、顺序结构的顺序文件可以快速检索（根据关键字快速找到记录）</li>
<li>最大缺点：不方便增加/删除</li>
</ul>
<p>索引文件：</p>
<ul>
<li>建立一张索引表，每个记录对应一个表项</li>
<li>索引表本身是定长的顺序文件，索引文件支持随机存取</li>
<li>索引表若按关键字顺序排列，则可实现快速检索</li>
<li>索引表可能占用很多空间</li>
</ul>
<p>索引顺序文件：</p>
<ul>
<li>将记录分组，每组对应一个索引表项</li>
<li>检索记录时先顺序检查索引表，找到分组，再顺序查找分组</li>
<li>记录过多时，可建立多级索引表</li>
</ul>
<h2 id="4-2文件目录"><a href="#4-2文件目录" class="headerlink" title="4.2文件目录"></a>4.2文件目录</h2><p>文件目录项FCB包含了文件的基本信息、存取控制信息、使用信息</p>
<ul>
<li>单级目录结构：不允许文件重名</li>
<li>两级目录结构：不同用户的文件可以重名，不能分类</li>
<li>多级（树形）目录结构：不方便文件共享，使用相对路径可以减少I/O操作</li>
<li>无环图目录结构：共享节点的技术器为0时才真正删除该节点</li>
</ul>
<p>索引节点：除了文件名之外的其他信息都放到索引节点中，每个文件对应一个索引节点，每个磁盘块可以放更多目录项，检索文件时磁盘I/O的次数减少</p>
<h2 id="4-3文件物理结构"><a href="#4-3文件物理结构" class="headerlink" title="4.3文件物理结构"></a>4.3文件物理结构</h2><p>顺序分配：</p>
<ul>
<li>顺序存取速度快，支持随机访问</li>
<li>会产生碎片</li>
</ul>
<p>隐式链接：</p>
<ul>
<li>可解决碎片问题，外存利用率高，文件拓展实现方便</li>
<li>只能顺序访问，不能随机存取</li>
</ul>
<p>显示链接：</p>
<ul>
<li>除了隐式链接的优点，还能实现随机访问</li>
<li>FAT（文件分配表）需要占用空间</li>
</ul>
<p>索引分配：</p>
<ul>
<li>支持随机访问，易实现文件拓展</li>
<li>索引表占用空间，可能需要多次读磁盘</li>
</ul>
<h2 id="4-4文件存储空间管理"><a href="#4-4文件存储空间管理" class="headerlink" title="4.4文件存储空间管理"></a>4.4文件存储空间管理</h2><ul>
<li>空闲表法：记录每个连续空闲区的起始盘块号、盘块数</li>
<li>空闲链表法：分为空闲盘块链和空闲盘区链</li>
<li>位示图法：一个二进制位代表一个盘块</li>
<li>成组链接法：UNIX采用的策略</li>
</ul>
<h2 id="4-5文件的基本操作"><a href="#4-5文件的基本操作" class="headerlink" title="4.5文件的基本操作"></a>4.5文件的基本操作</h2><p>打开文件：</p>
<ul>
<li>将目录项中的信息复制到内存中的打开文件表中，并将打开文件表的索引号返回给用户</li>
<li>每个进程有自己的打开文件表，系统也有一张总的打开文件表</li>
</ul>
<h2 id="4-6文件共享"><a href="#4-6文件共享" class="headerlink" title="4.6文件共享"></a>4.6文件共享</h2><p>分为硬链接和软链接</p>
<p>硬链接：各个用户的目录项指向同一个索引节点，需要链接计数count</p>
<p>软链接：在一个Link型的文件中记录共享文件的存放路径，访问速度较慢，有查询失败的可能</p>
<h2 id="4-7文件保护"><a href="#4-7文件保护" class="headerlink" title="4.7文件保护"></a>4.7文件保护</h2><p>口令保护：为文件设置口令，但是不安全</p>
<p>加密保护：用密码对文件进行加密，安全性高，但是耗费时间</p>
<p>访问控制：用访问控制表（ACL）来记录各个用户对文件的访问权限</p>
<h2 id="4-8文件系统的层次结构"><a href="#4-8文件系统的层次结构" class="headerlink" title="4.8文件系统的层次结构"></a>4.8文件系统的层次结构</h2><p>用户接口、文件目录系统、存取控制模块、逻辑文件系统与文件信息缓冲区、物理文件系统、设备管理程序模块、辅助分配模块</p>
<h2 id="4-9磁盘的结构"><a href="#4-9磁盘的结构" class="headerlink" title="4.9磁盘的结构"></a>4.9磁盘的结构</h2><p>磁盘、磁道、扇区、盘面、柱面</p>
<p>磁盘的物理地址：柱面号、盘面号、扇区号</p>
<p>磁盘的分类：固定头磁盘、移动头磁盘、固定盘磁盘、可更换磁盘</p>
<h2 id="4-10磁盘调度算法"><a href="#4-10磁盘调度算法" class="headerlink" title="4.10磁盘调度算法"></a>4.10磁盘调度算法</h2><p>一次磁盘读写操作需要的时间：寻找时间+延迟时间+传输时间</p>
<ul>
<li>先来先服务算法（FCFS）：根据进程请求顺序进行调度</li>
<li>最短寻找时间优先（SSTF）：优先处理与当前磁头最近的磁道，可能产生饥饿现象</li>
<li>扫描算法（SCAN）：磁头来回扫描，不会产生饥饿现象，但是对各个磁道响应频率不平均</li>
<li>LOOK调度算法：边移动边观察，若行进方向上没有请求就掉头，减少了寻道时间</li>
<li>循环扫描算法（C-SCAN）：在SCAN的基础上，到头后立即返回至起始端，响应平均但寻道时间增加了</li>
<li>C-LOOK调度算法：在C-SCAN的基础上，返回到最远的请求出即可</li>
</ul>
<h2 id="4-11减少磁盘延迟时间"><a href="#4-11减少磁盘延迟时间" class="headerlink" title="4.11减少磁盘延迟时间"></a>4.11减少磁盘延迟时间</h2><p>交替编号：让编号相邻的扇区在物理上不相邻</p>
<p>错位命名：让相邻盘面的扇区编号错位</p>
<p>为什么用（柱面号、盘面号、扇区号）的结构，而不用（盘面号、柱面号、扇区号）的结构？</p>
<p>原因：在读取地址连续的磁盘块时，前者不需要移动磁头</p>
<h2 id="4-12磁盘的管理"><a href="#4-12磁盘的管理" class="headerlink" title="4.12磁盘的管理"></a>4.12磁盘的管理</h2><p>磁盘初始化：</p>
<ul>
<li>低级格式化：划分扇区</li>
<li>磁盘分区</li>
<li>逻辑格式化：建立文件系统</li>
</ul>
<p>引导块：ROM中放入自举装入程序，完整的自举程序放在引导块中</p>
<p>坏块的管理：</p>
<ul>
<li>简单磁盘：逻辑格式化时将坏块标记出来</li>
<li>复杂磁盘：磁盘控制器维护一个坏块链，并管理备用扇区</li>
</ul>
<h1 id="5-I-O管理"><a href="#5-I-O管理" class="headerlink" title="5.I/O管理"></a>5.I/O管理</h1><h2 id="5-1I-O设备的基本概念与分类"><a href="#5-1I-O设备的基本概念与分类" class="headerlink" title="5.1I/O设备的基本概念与分类"></a>5.1I/O设备的基本概念与分类</h2><p>按信息交换的单位分类：</p>
<ul>
<li>块设备：传输快，可寻址</li>
<li>字符设备：传输慢，不可寻址，常采用中断驱动方式 </li>
</ul>
<h2 id="5-2I-O控制器"><a href="#5-2I-O控制器" class="headerlink" title="5.2I/O控制器"></a>5.2I/O控制器</h2><p>主要功能：</p>
<ul>
<li>接受和识别CPU的命令（控制寄存器）</li>
<li>向CPU报告设备的状态（状态寄存器）</li>
<li>数据交换（数据寄存器）</li>
<li>地址识别（I/O逻辑）</li>
</ul>
<p>组成：</p>
<ul>
<li>CPU与控制器之间的接口</li>
<li>I/O逻辑</li>
<li>控制器与设备之间的接口</li>
</ul>
<p>两种寄存器编址方式：</p>
<ul>
<li>内存映射I/O：控制器中的寄存器与内存统一编址，可采用对内存进行操作的指令对控制器进行操作</li>
<li>寄存器独立编址：控制器中的寄存器独立编址，需要设置专门的指令来操作控制器</li>
</ul>
<h2 id="5-3I-O控制方式"><a href="#5-3I-O控制方式" class="headerlink" title="5.3I/O控制方式"></a>5.3I/O控制方式</h2><p>程序直接控制方式：CPU发出I/O命令后需要不断轮询</p>
<p>中断驱动方式：CPU发出命令后可以做其他事，I/O完成后设备控制器发出中断信号</p>
<p>DMA方式：传输块，跳开CPU，由DMA控制器发出中断信号</p>
<p>通道控制方式：传输一组块</p>
<h2 id="5-4I-O软件层次结构"><a href="#5-4I-O软件层次结构" class="headerlink" title="5.4I/O软件层次结构"></a>5.4I/O软件层次结构</h2><p>从用户到硬件：</p>
<ul>
<li>用户层软件：与用户交互，提供库函数</li>
<li>设备独立性软件：向上提供调用接口，设备的保护，差错处理，设备的分配与回收，数据缓冲区管理，建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用响应的驱动程序</li>
<li>设备驱动程序：设置设备寄存器，检查设备状态</li>
<li>中断处理程序：进行中断处理</li>
<li>硬件：执行I/O操作</li>
</ul>
<h2 id="5-5I-O核心子系统"><a href="#5-5I-O核心子系统" class="headerlink" title="5.5I/O核心子系统"></a>5.5I/O核心子系统</h2><p>设备独立性软件、设备驱动软件、中断处理程序</p>
<h2 id="5-6假脱机技术"><a href="#5-6假脱机技术" class="headerlink" title="5.6假脱机技术"></a>5.6假脱机技术</h2><p>脱机技术：缓解设备与CPU的速度矛盾，实现预输入，缓输出</p>
<p>假脱机技术：软件方式模拟脱机技术，通过输入井和输出井、输入缓冲区和输出缓冲区模拟，相当于建立中转站</p>
<h2 id="5-7设备的分配与回收"><a href="#5-7设备的分配与回收" class="headerlink" title="5.7设备的分配与回收"></a>5.7设备的分配与回收</h2><p>设备分配管理中的数据结构：</p>
<ul>
<li>设备控制表DCT</li>
<li>控制器控制表COCT</li>
<li>通道控制表CHCT</li>
<li>系统控制表SDT</li>
</ul>
<p>设备分配：</p>
<ul>
<li>根据进程请求的物理设备名查找SDT</li>
<li>根据SDT查找DCT并分配设备</li>
<li>根据DCT查找COCT并分配控制器</li>
<li>根据COCT查找CHCT并分配通道</li>
</ul>
<p>缺点：必须使用物理设备名，若物理设备更换则程序无法运行，同类设备也会出现阻塞问题</p>
<p>改进：使用逻辑设备名，操作系统负责实现映射（逻辑设备表）</p>
<p>逻辑设备表（LUT）设置：</p>
<ul>
<li>整个系统只有一张LUT，适用于单用户操作系统</li>
<li>每个用户一张LUT，适用于多用户操作系统</li>
</ul>
<h2 id="5-8缓冲区管理"><a href="#5-8缓冲区管理" class="headerlink" title="5.8缓冲区管理"></a>5.8缓冲区管理</h2><p>单缓冲</p>
<ul>
<li>处理平均耗时：Max（C，T）+M</li>
</ul>
<p>双缓冲</p>
<ul>
<li>处理平均耗时：Max（T，C+M）</li>
</ul>
<p>循环缓冲</p>
<ul>
<li>多个缓冲区链接成循环队列，in指针指向第一个空缓冲区，out指针指向第一个满缓冲区</li>
</ul>
<p>缓冲池</p>
<ul>
<li>三个队列：空缓冲队列、输入队列、输出队列</li>
<li>四个缓冲区：收容输入数据、提取输入数据、收容输出数据、提取输出数据</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/" data-id="ckct9przf0000pwv2ae2cankg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-博客入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/18/%E5%8D%9A%E5%AE%A2%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2020-07-18T05:15:30.844Z" itemprop="datePublished">2020-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/18/%E5%8D%9A%E5%AE%A2%E5%85%A5%E9%97%A8/">博客入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h1><p>博客基于Node.js构建，创建博客前需要一些准备工作</p>
<p>首先从<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 上下载Node.js并安装</p>
<p>启动cmd，查看node版本，命令：node -v或node –version</p>
<p>查看npm版本</p>
<p>安装cnpm，命令：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> ，安装后cnpm命令可用</p>
<p>安装hexo，命令：cnpm install -g hexo-cli</p>
<p>查看hexo版本：hexo -v</p>
<p>建立一个空文件夹，进入</p>
<p>建立博客，命令：hexo init</p>
<ul>
<li>此处可能遇到问题，需要下载git并配置</li>
</ul>
<p>建立后用hexo s可以启动博客预览</p>
<p>cd到source文件夹中，查看md文件，可以进行编辑（vim或是typora）</p>
<p>编辑之后需要重新生成，hexo clean清理，hexo g重新生成</p>
<h1 id="远端部署"><a href="#远端部署" class="headerlink" title="远端部署"></a>远端部署</h1><p>登录github，创建new repository，名称为”用户名.github.io”</p>
<p>cmd中输入命令：cnpm install –save hexo-deployer-git</p>
<p>进入_config.yml文件，在尾部进行修改：</p>
<ul>
<li>type:+空格+git</li>
<li>repo:+空格+github上的地址如： <a href="https://github.com/wkccm/wkccm.github.io.git" target="_blank" rel="noopener">https://github.com/wkccm/wkccm.github.io.git</a> </li>
<li>branch:+空格+master</li>
</ul>
<p>部署到远端：hexo d</p>
<ul>
<li>此处若出现error，根据提示输入相应命令，并输入用户名与邮箱及密码等</li>
</ul>
<p>然后打开<a href="https://wkccm.github.io/" target="_blank" rel="noopener">https://wkccm.github.io/</a> 即可在远端查看博客</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/18/%E5%8D%9A%E5%AE%A2%E5%85%A5%E9%97%A8/" data-id="ckcraa0q800015gv2ftg0bere" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/18/hello-world/" class="article-date">
  <time datetime="2020-07-18T04:55:39.932Z" itemprop="datePublished">2020-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/18/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/18/hello-world/" data-id="ckcraa0py00005gv22w0q62je" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/25/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">MySQL知识点归纳</a>
          </li>
        
          <li>
            <a href="/2020/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/">计算机网络复习提纲</a>
          </li>
        
          <li>
            <a href="/2020/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/">计算机组成原理复习提纲</a>
          </li>
        
          <li>
            <a href="/2020/07/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/">操作系统复习提纲</a>
          </li>
        
          <li>
            <a href="/2020/07/18/%E5%8D%9A%E5%AE%A2%E5%85%A5%E9%97%A8/">博客入门</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>